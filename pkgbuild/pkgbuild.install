#!/usr/bin/env bash
# -*- coding: utf-8 -*-
# shellcheck shell=bash disable=SC1091,SC2039,SC2166
#
#  pkgbuild.install
#  Created: 2024/09/09 - 08:57
#  Updated: qua 07 mai 2025 12:31:30 -04
#
#  Copyright (c) 2024-2025, Vilmar Catafesta <vcatafesta@gmail.com>
#  All rights reserved.
#
#  Redistribution and use in source and binary forms, with or without
#  modification, are permitted provided that the following conditions
#  are met:
#  1. Redistributions of source code must retain the above copyright
#     notice, this list of conditions and the following disclaimer.
#  2. Redistributions in binary form must reproduce the above copyright
#     notice, this list of conditions and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#
#  THIS SOFTWARE IS PROVIDED BY THE AUTHOR AS IS'' AND ANY EXPRESS OR
#  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
#  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
#  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
#  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
#  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
#  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
#  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
#  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
#  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
##############################################################################
export TERM=${TERM:-xterm}
export TERM=${TERM:-xterm-256color}

# Defining color variables (bold only)
export black="\033[1;30m"
export red="\033[1;31m"
export green="\033[1;32m"
export yellow="\033[1;33m"
export blue="\033[1;34m"
export magenta="\033[1;35m"
export cyan="\033[1;36m"
export white="\033[1;37m"
export bold="\033[1m"
export reset="\033[0m"
export normal_black="\033[0;30m"
export normal_red="\033[0;31m"
export normal_green="\033[0;32m"
export normal_yellow="\033[0;33m"
export normal_blue="\033[0;34m"
export normal_magenta="\033[0;35m"
export normal_cyan="\033[0;36m"
export normal_white="\033[0;37m"
export bright_black="\033[1;90m"
export bright_red="\033[1;91m"
export bright_green="\033[1;92m"
export bright_yellow="\033[1;93m"
export bright_blue="\033[1;94m"
export bright_magenta="\033[1;95m"
export bright_cyan="\033[1;96m"
export bright_white="\033[1;97m"
#
export COL_NC='\e[0m' # No Color
export COL_LIGHT_GREEN='\e[1;32m'
export COL_LIGHT_RED='\e[1;31m'
export TICK="${white}[${COL_LIGHT_GREEN}✓${COL_NC}${white}]"
export CROSS="${white}[${COL_LIGHT_RED}✗${COL_NC}${white}]"
export INFO="[i]"
export DONE="${COL_LIGHT_GREEN} done!${COL_NC}"
export OVER="\\r\\033[K"
export DOTPREFIX="  ${black}::${reset} "
#
declare user="${SUDO_USER:-$USER}"
declare user_home=$(getent passwd "$user" | cut -d: -f6)
declare IS_UPGRADE=false
declare IS_DBLOCK=false
declare IS_METAPKG=false
declare DM='lightdm'
declare WM='chili-gitrepo'
declare pkgname="${WM}"
declare servicesToEnable=()
declare servicesToDisable=()

msg() {
	local msg="$1"
	echo -e "${blue}==>${black}[${pkgname}] ${bright_cyan}${msg}${reset}" >&2
}

log_ok() { echo -e "  ${TICK} ${*}${reset}"; }
log_err() { echo -e "  ${CROSS} ${*}${reset}"; }

sh_remove_lock() {
	if [[ -f /var/lib/pacman/db.lck ]]; then
		IS_DBLOCK=true
		msg "Removing pacman lock: /var/lib/pacman/db.lck"
		rm -f /var/lib/pacman/db.lck &>/dev/null
	fi
}

sh_restoring_lock() {
	if $IS_DBLOCK; then
		msg "Restauring pacman lock: /var/lib/pacman/db.lck"
		touch /var/lib/pacman/db.lck &>/dev/null
	fi
}

die() {
	local msg="$1"
	shift
	echo -e "  ${CROSS} ${red}${msg}${reset}"
	sh_restoring_lock
	exit 1
}

sh_load_optdepends() {
	local info_file="/usr/share/${pkgname}/optdepends"

	if [[ -s "$info_file" ]]; then
		#mapfile -t OPTDEPENDS <"$info_file"
		#OPTDEPENDS=()
		#while IFS= read -r line; do
		#  [[ -n "${line// /}" ]] && OPTDEPENDS+=("$line")
		#done < "$info_file"
		mapfile -t OPTDEPENDS < <(grep -v '^\s*$' "$info_file")
	else
		OPTDEPENDS=()
		if $IS_METAPKG; then
			msg "${yellow}AVISO: '$info_file' está vazio. Nenhum optdepend será carregado."
		fi
	fi
}

sh_check_package_exist() {
	local pkg
	local not_installed=()
	local not_found=()

	# Verifica pacotes instalados localmente de uma vez
	for pkg in "${OPTDEPENDS[@]}"; do
		if ! pacman -Qq "$pkg" &>/dev/null; then
			not_installed+=("$pkg")
		fi
	done

	# Verifica pacotes ausentes no repositório de uma vez
	if ((${#not_installed[@]})); then
		for pkg in "${not_installed[@]}"; do
			if ! pacman -Ssq "^$pkg$" &>/dev/null; then
				not_found+=("$pkg")
			fi
		done
	fi

	# Se houver pacotes não encontrados, exibe erro
	if ((${#not_found[@]})); then
		die "Fatal: os seguintes pacotes não existem no repositório: ${not_found[*]}"
	fi

	for pkg in "${OPTDEPENDS[@]}"; do
		log_ok "Check: ${cyan}$pkg"
	done
}

sh_start_dbus_in_chroot() {
	# Verifica se o D-Bus já está em execução
	if ! pgrep -x "dbus-daemon" >/dev/null; then
		# Cria o diretório para o socket do D-Bus
		mkdir -p /run/dbus
		chmod 755 /run/dbus

		# Inicia o D-Bus
		dbus-daemon --system --fork

		# Configura as variáveis de ambiente
		export DBUS_SESSION_BUS_ADDRESS=unix:path=/run/dbus/system_bus_socket
		export DBUS_SYSTEM_BUS_ADDRESS=unix:path=/run/dbus/system_bus_socket
	fi
}

sh_copy_user_etc_usr_opt_files() {
	msg "Copying files and directories from package..."

	# Copiar a estrutura para os diretórios de destino
	local dirs=("usr" "etc" "opt")

	for dir in "${dirs[@]}"; do
		if [ -d "/usr/share/${pkgname}/${dir}" ]; then
			# Copiar os arquivos e subdiretórios de /usr/share/${pkgname}/${dir} para o sistema
			cp -a "/usr/share/${pkgname}/${dir}" "/"
		fi
	done
}

sh_blacklist_nouveau_drivers() {
	msg "Blacklisting Nouveau..."
	mkdir -p /etc/modprobe.d/ &>/dev/null
	echo -e "blacklist nouveau\ninstall nouveau /bin/true" >/etc/modprobe.d/nouveau.conf
	echo -e "blacklist nouveau\ninstall nouveau /bin/true" >/etc/modprobe.d/blacklist.conf
}

detect_and_install_gpu_drivers() {
	msg "Detecting GPU and installing appropriate drivers..."
	GPU_INFO=$(lspci -nnk | grep -A3 -E "VGA|3D|Display")

	if grep -qiw "NVIDIA" <<<"$GPU_INFO"; then
		msg "NVIDIA detected! Installing drivers..."
		msg "Detect kernel version and set package name"
		KERNEL_VERSION=$(uname -r | cut -d '.' -f1,2 | tr -d '.')
		KERNEL_PACKAGE="linux${KERNEL_VERSION}-nvidia"
		msg "Detected kernel: $KERNEL_VERSION"
		msg "Installing NVIDIA packages: $KERNEL_PACKAGE nvidia-utils nvidia-settings"
		install_packages "$KERNEL_PACKAGE" nvidia-utils nvidia-settings
		sh_blacklist_nouveau_drivers
		:
	elif grep -qiw "Intel" <<<"$GPU_INFO"; then
		msg "Intel GPU detected! Installing drivers..."
		install_packages vulkan-intel lib32-vulkan-intel
		:
	elif grep -qEiw "AMD|ATI" <<<"$GPU_INFO"; then
		msg "AMD/ATI GPU detected! Installing drivers..."
		install_packages mesa-utils \
			vulkan-icd-loader lib32-vulkan-icd-loader \
			vulkan-headers vulkan-radeon lib32-vulkan-radeon \
			mhwd-amdgpu mhwd-ati
		:
	else
		msg "${yellow}Warning: No compatible GPU detected. Skipping driver installation.${reset}"
	fi
}

ensure_group_user() {
	local user="$1"
	local group="$2"
	getent group "$group" &>/dev/null || sudo groupadd "$group" &>/dev/null
	id -nG "$user" | grep -qw "$group" || sudo gpasswd -a "$user" "$group" &>/dev/null
}

sh_get_real_user() {
	user="${SUDO_USER:-$USER}"

	# Se o usuário não existir, tenta encontrar um UID >= 1000
	if ! getent passwd "$user" >/dev/null; then
		user=$(awk -F: '$3 >= 1000 && $3 < 65000 { print $1; exit }' /etc/passwd)
	fi

	# Se estiver no ambiente chroot e uma variável de usuário foi definida
	if [[ $IN_CHROOT_INSTALLER == true ]]; then
		if [[ -n $IN_CHROOT_INSTALLER_USER && $IN_CHROOT_INSTALLER_USER != "root" ]]; then
			user="$IN_CHROOT_INSTALLER_USER"
		fi
	fi

	# Descobre o diretório home do usuário
	user_home=$(getent passwd "$user" | cut -d: -f6)

	# Fallback para /home/$user se user_home estiver vazio
	if [[ -z "$user_home" ]]; then
		user_home="/home/$user"
	fi

	export user
	export user_home
}

post_install() {
	msg "Initializing system installation and configuration..."
	sh_copy_user_etc_usr_opt_files
	sh_load_optdepends

	[[ -e /etc/environment ]] && source /etc/environment
	: "${IN_CHROOT_INSTALLER:=false}"
	: "${IN_CHROOT_INSTALLER_USER:=root}"

	if $IN_CHROOT_INSTALLER; then
		# sh_start_dbus_in_chroot
		:
	fi

	if ((${#OPTDEPENDS[@]})); then
		# Removing pacman lock: /var/lib/pacman/db.lck
		sh_remove_lock

		synchronizing_database() {
			pacman -Sy --quiet --noconfirm 1>/dev/null
		}

		install_packages() {
			local error_log="/tmp/${pkgname}-pacman_error_log"
			local output_log="/tmp/${pkgname}-pacman_output_log"
			local max_attempts=3

			# Primeira tentativa em lote
			if ! LC_ALL=C pacman -S --quiet --noconfirm --needed --overwrite '*' "$@" >"$output_log" 2>"$error_log"; then
				log_err "Falha na instalação inicial, tentando novamente..."
				local attempt=1
				while ((attempt <= max_attempts)); do
					msg "Tentando reinstalar os pacotes (tentativa $attempt de $max_attempts)..."
					if LC_ALL=C pacman -S --quiet --noconfirm --needed --overwrite '*' "$@" >>"$output_log" 2>>"$error_log"; then
						log_ok "Todos os pacotes foram instalados com sucesso."
						break
					fi
					((attempt++))
				done

				if ((attempt > max_attempts)); then
					log_err "Falhou após $max_attempts tentativas."
					cat "$error_log"
					die "Erro fatal ao instalar os pacotes."
				fi
			fi

			# Limpa arquivos temporários
			rm -f "$error_log" "$output_log"
			return 0
		}

		msg "Please wait, synchronizing databases..."
		synchronizing_database

		#msg "Checking for the existence of packages..."
		#sh_check_package_exist

		if $IS_METAPKG; then
			msg "Reinstalling package pipewire-jack..."
			pacman -S --quiet --noconfirm --overwrite \* pipewire-jack &>/dev/null
		fi

		if ((${#OPTDEPENDS[@]})); then
			msg "Installing optdepends packages..."
			install_packages "${OPTDEPENDS[@]}"
		fi

		if $IS_METAPKG; then
			if ! $IS_UPGRADE; then
				#detect_and_install_gpu_drivers
				sh_blacklist_nouveau_drivers
			fi

			msg "Setting up user..."
			sh_get_real_user

			msg "Checking if $user is in autologin group"
			ensure_group_user "$user" autologin

			if ! $IS_UPGRADE; then
				msg "Copying skel to $user_home..."
				mkdir -p "$user_home" &>/dev/null
				cp -Rfpa /etc/skel/. "$user_home/" &>/dev/null

				msg "Setting user folder permissions in ${user_home}"
				chown -R "$user:$user" "$user_home" &>/dev/null

				if command -v nautilus >/dev/null; then
					msg "Configuring Nautilus..."
					if glib-compile-schemas /usr/share/glib-2.0/schemas/; then
						msg "Nautilus schemas compiled successfully!"
					else
						msg "${yellow}Warning: Failed to compile Nautilus schemas. Some features may not work correctly.${reset}"
					fi
				fi
			fi

			sh_change_grub() {
				msg "Configuring GRUB..."
				# Change GRUB config
				if ! grep -qi "${WM}" /etc/default/grub; then
					sed -i "s/^GRUB_DISTRIBUTOR=\"\(.*\)\"/GRUB_DISTRIBUTOR=\"\1 ${WM^}\"/" /etc/default/grub
				fi
				sed -i 's|^GRUB_CMDLINE_LINUX_DEFAULT=.*|GRUB_CMDLINE_LINUX_DEFAULT="quiet splash plymouth.enable=1 loglevel=4 libata.noacpi=1 acpi=force apm=power-off nowatchdog tsc=nowatchdog cryptomgr.notests no_timer_check rcupdate.rcu_expedited=1 intel_pstate=active amd_pstate=active cpuidle.governor=teo split_lock_detect=off clearcpuid=514 transparent_hugepage=never skew_tick=1 intremap=off nosoftlockup audit=0 nomce systemd.show_status=auto rd.udev.log_level=3 apparmor=1 security=apparmor vconsole.font=Uni2-Fixed16 intel_iommu=on amd_iommu=on tdx=on nvme_load=yes nouveau.modeset=1 i915.modeset=1 amdgpu.modeset=1 radeon.si_support=0 radeon.cik_support=0 amdgpu.si_support=1 amdgpu.cik_support=1 nvidia.modeset=1 nvidia_drm.modeset=1 DEEPIN_GFXMODE="|' /etc/default/grub 1>/dev/null
			}

			if ! $IN_CHROOT_INSTALLER; then
				if ! $IS_UPGRADE; then
					msg "Please wait, Generating initramfs for all kernels..."
					mkinitcpio -P &>/dev/null
				fi
				sh_change_grub
				msg "Generating GRUB configuration files..."
				update-grub &>/dev/null
			fi
		fi

		# Restauring pacman lock: /var/lib/pacman/db.lck
		sh_restoring_lock
	fi

  for service in "${servicesToDisable[@]}"; do
    if systemctl is-active --quiet "${service}"; then
      if systemctl disable "${service}" &>/dev/null; then
        log_ok "Service ${service} is inactive..."
      else
        log_err "${red}Error: It went wrong when desactivating service ${service}"
      fi
    else
      log_ok "Service ${service} is already inactive..."
    fi
  done

  for service in "${servicesToEnable[@]}"; do
    if systemctl is-active --quiet "${service}"; then
      log_ok "Service ${service} is already active..."
    else
      if systemctl enable "${service}" &>/dev/null; then
        log_ok "Service ${service} activated..."
      else
        log_err "${red}Error: It went wrong when activating service ${service}"
      fi
    fi
  done

	if $IS_METAPKG; then
		if ! $IS_UPGRADE; then
			msg "Installation complete. Rebooting in 10 seconds..."
			# Countdown before reboot
			for i in $(seq 10 -1 1); do
				printf "%d..." "$i"
				sleep 1
			done
			echo
			msg "Rebooting now..."
			reboot
		fi
	fi
	msg "${green}Install/Upgrade complete."
}

post_upgrade() {
	IS_UPGRADE=true
	post_install
}
