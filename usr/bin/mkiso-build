#!/usr/bin/env bash
#-*- coding: utf-8 -*-
#shellcheck shell=bash disable=SC2034,SC2183,SC2016,SC2154
#
#  mkiso-build - Wrapper bash para o buildiso
#  Ferramenta auxiliar para o buildiso, adicionando automações, validações e opções customizadas
#  ao fluxo padrão de construção de ISOs.
#
#  Created: ter 24 set 2024 04:26:12 -04
#  Altered: dom 08 dez 2024 23:39:02 -04
#  Updated: qui 27 fev 2025 23:55:11 -04
#
#  Copyright (c) 2024-2025, Vilmar Catafesta <vcatafesta@gmail.com>
#  All rights reserved.
#
#  Redistribution and use in source and binary forms, with or without
#  modification, are permitted provided that the following conditions
#  are met:
#  1. Redistributions of source code must retain the above copyright
#     notice, this list of conditions and the following disclaimer.
#  2. Redistributions in binary form must reproduce the above copyright
#     notice, this list of conditions and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#
#  THIS SOFTWARE IS PROVIDED BY THE AUTHOR AS IS'' AND ANY EXPRESS OR
#  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
#  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
#  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
#  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
#  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
#  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
#  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
#  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
#  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
##############################################################################
declare APP="${0##*/}"
declare APPDESC="Wrapper bash para o buildiso"
declare VERSION="1.02.27"
export TERM=${TERM:-xterm}
export TERM=${TERM:-xterm-256color}
declare IS_AUTO=false
declare PARAM_DEFAULT=false
declare VALUE_DEFAULT=false
declare IS_ADD_PERFIL=false
declare IS_ADD_PROFILE=false
declare IS_BUILD_ISO_RESUME=true
declare HOME_DIR="$HOME/.${APP}"
declare config_file="${HOME_DIR}/mkiso-build.ini"
declare ccabec=''
# necessário definir global por conta que o bash exporta somente variáveis escalares e não array
declare -a aDistros
declare -a aBranchs
declare -a aKernels
declare -a aProfiles
declare -A ApiProfiles
declare -a aCustomPerfilName
declare -A ACustomPerfilKey

configure_base_vars() {
	# Declare variáveis de ambiente
	# somente ativada quando rodar manualmente (-m), no github não é necessário
	aDistros=('bigcommunity' 'biglinux' 'chililinux' 'manjaro' 'Sair')
	aBranchs=('stable' 'testing' 'unstable' 'Sair')
	aKernels=('latest' 'lts' 'oldlts' 'xanmod' 'Sair')
	aProfiles=(
		'https://github.com/communitybig/iso-profiles'
		'https://github.com/biglinux/iso-profiles'
		'https://github.com/chililinux/iso-profiles'
		'https://gitlab.manjaro.org/profiles-and-settings/iso-profiles.git'
		'https://github.com/vcatafesta/iso-profiles'
	)
	ApiProfiles=(
		# GitHub Repositories
		['https://github.com/communitybig/iso-profiles']='https://api.github.com/repos/communitybig/iso-profiles/contents/'
		['https://github.com/biglinux/iso-profiles']='https://api.github.com/repos/biglinux/iso-profiles/contents/'
		['https://github.com/chililinux/iso-profiles']='https://api.github.com/repos/chililinux/iso-profiles/contents/'
		['https://github.com/vcatafesta/iso-profiles']='https://api.github.com/repos/vcatafesta/iso-profiles/contents/'
		# GitLab Repositories
		['https://gitlab.manjaro.org/profiles-and-settings/iso-profiles.git']='https://gitlab.manjaro.org/api/v4/projects/profiles-and-settings%2Fiso-profiles/repository/tree'
	)
	#
	mkdir -p "$HOME_DIR" 1>/dev/null
	sh_read_custom_repositorys
	aProfiles+=('Sair')
	declare -g IS_BUILD_ISO=true
	declare -g ORGANIZATION='<local>'
	declare -g REPO_WORKFLOW='<local>'
	declare -g REPO_PATH="$PWD"
	declare -g USERNAME="$USER"
	declare -g GITHUB_USER_NAME="$USERNAME"
	declare -g HOME_FOLDER="/home/$USERNAME"
}
export -f configure_base_vars

configure_vars() {
	configure_base_vars
	declare -g DISTRONAME
	declare -g BUILD_DIR
	declare -g EDITION
	declare -g KERNEL
	declare -g TMATE
	declare -g DEBUG
	declare -g MANJARO_BRANCH
	declare -g BIGLINUX_BRANCH
	declare -g BIGCOMMUNITY_BRANCH
	declare -g CHILILINUX_BRANCH
	declare -g ISO_PROFILES_REPO
	declare -g DISTRONAME_ISOPROFILES

	sh_get_values() {
		if $VALUE_DEFAULT; then
			get_perfil
		else
			if ! $PARAM_DEFAULT; then
				get_distroname
				get_iso_profiles_repo
				get_build_list "$ISO_PROFILES_REPO"
				get_edition "$ISO_PROFILES_REPO" "$BUILD_DIR"
			fi
		fi
		DISTRONAME_ISOPROFILES="$(get_distroname_isoprofiles)"
		WORK_PATH="$HOME_FOLDER/__w/build-iso/build-iso"
		WORK_PATH_ISO_PROFILES="$HOME_FOLDER/__w/build-iso/build-iso/iso-profiles"
		PROFILE_PATH="$HOME_FOLDER/__w/build-iso/build-iso/iso-profiles/${BUILD_DIR}"
		PROFILE_PATH_EDITION="$HOME_FOLDER/__w/build-iso/build-iso/iso-profiles/${BUILD_DIR}/$EDITION"
		PATH_MANJARO_ISO_PROFILES='/usr/share/manjaro-tools/iso-profiles'
		PATH_MANJARO_TOOLS='/usr/share/manjaro-tools'
		VAR_CACHE_MANJARO_TOOLS='/var/cache/manjaro-tools'
		VAR_CACHE_MANJARO_TOOLS_ISO='/var/cache/manjaro-tools/iso'
		RELEASE_TAG=$(date "+%Y-%m-%d_%H-%M")
		if ! $VALUE_DEFAULT; then
			sh_readconf
		fi
	}

	sh_readconf() {
		if ! $PARAM_DEFAULT; then
			get_manjaro_branch
			if [[ "$DISTRONAME" =~ ^(manjaro)$ ]]; then
				BIGCOMMUNITY_BRANCH=
				BIGLINUX_BRANCH=
				CHILILINUX_BRANCH=
			else
				get_biglinux_branch
			fi
			if [[ "$DISTRONAME" =~ ^(manjaro|biglinux|chililinux)$ ]]; then
				BIGCOMMUNITY_BRANCH=
			else
				get_bigcommunity_branch
			fi
			if [[ "$DISTRONAME" =~ ^(manjaro|biglinux|bigcommunity|talesam)$ ]]; then
				CHILILINUX_BRANCH=
			else
				get_chililinux_branch
			fi
			get_kernel
			get_debug
			sh_showchoices
		fi
	}

	if ! $IS_ADD_PROFILE; then
		sh_get_values
		mkdir -p "$WORK_PATH" &>/dev/null
		pushd "$WORK_PATH" &>/dev/null || false
		resume_and_build
	fi
}
export -f configure_vars

sh_get_all_custom_perfil() {
	local last_key=$(TIni.Get "$config_file" "perfil" 'keys')
	local str
	local name
	local Names

	aCustomPerfilName=()
	ACustomPerfilKey=()

	if [[ ! -z "$last_key" ]]; then
		for ((i = 1; i <= last_key; i++)); do
			str=$(TIni.Get "$config_file" "perfil" "$i")
			name=$(sh_splitarray "${str}" 1)
			Names+="$name "
			aCustomPerfilName+=("$name")
			ACustomPerfilKey+=(["$name"]="$i")
		done
	fi
	#	echo "$Names"
}

sh_check_is_any_perfil_exist() {
	sh_get_all_custom_perfil
	if [[ "${#aCustomPerfilName[@]}" -eq 0 ]]; then
		if conf "${YELLOW}Nenhum perfil disponível, deseja incluir?"; then
			ccabec="$APP --create_perfil - Adicionar perfil customizado de ISO"
			IS_AUTO=false
			VALUE_DEFAULT=false
			PARAM_DEFAULT=false
			IS_ADD_PERFIL=true
			configure_vars
			exit 0
		fi
		return 1
	fi
	return 0
}

sh_list_perfil() {
	local ccabec="$APP --list_perfil - Listar perfis customizados de ISO"
	local count
	local key
	local perfil_name

	if sh_check_is_any_perfil_exist; then
		count=0 # Contador para numerar corretamente
		for key in "${!ACustomPerfilKey[@]}"; do
			perfil_name="${ACustomPerfilKey[$key]}"

			# Verifica se o perfil tem um nome válido
			if [[ -n "$perfil_name" ]]; then
				((count++))
				printf "${bold}${white}%02d :: ${yellow}%s\n${rst}" "$count" "$key"
			fi
		done

		# Se nenhum perfil válido foi encontrado, exibir "<none>"
		[[ $count -eq 0 ]] && printf "${yellow}%s\n${rst}" "<none>"
	fi
	exit 0
}

get_perfil() {
	if sh_check_is_any_perfil_exist; then
		aCustomPerfilName+=("Sair")
		create_menu_with_array "Escolha um ${yellow}PERFIL:" aCustomPerfilName[@]
		if [[ $MENU_RESULT == "Sair" ]]; then
			die "${red}" "Seleção de PERFIl cancelado.${reset}"
		fi
		PERFIL="${MENU_RESULT}"
		sh_read_custom_perfil "${ACustomPerfilKey[$PERFIL]}"
		return 0
	fi
	return 1
}

sh_remove_custom_perfil() {
	if sh_check_is_any_perfil_exist; then
		aCustomPerfilName+=("Sair")
		create_menu_with_array "Escolha um ${yellow}PERFIL:" aCustomPerfilName[@]
		if [[ $MENU_RESULT == "Sair" ]]; then
			die "${red}" "Seleção de PERFIl cancelado.${reset}"
		fi
		PERFIL="${MENU_RESULT}"
		if conf "${YELLOW}Deseja excluir o perfil selecionado?"; then
			if TIni.RemoveAndReindex "$config_file" "perfil" "${ACustomPerfilKey[$PERFIL]}"; then
				msg_ok "Perfil $PERFIL foi para as picas!"
			else
				die "Opsss, Deu ruim na remoção do perfil $PERFIL!"
			fi
		fi
	fi
}

sh_read_custom_perfil() {
	local key="$1"

	DISTRONAME="$(sh_splitarray "$(TIni.Get "$config_file" "perfil" "$key")" 2)"
	ISO_PROFILES_REPO="$(sh_splitarray "$(TIni.Get "$config_file" "perfil" "$key")" 3)"
	DISTRONAME_ISOPROFILES="$(sh_splitarray "$(TIni.Get "$config_file" "perfil" "$key")" 4)"
	BUILD_DIR="$(sh_splitarray "$(TIni.Get "$config_file" "perfil" "$key")" 5)"
	EDITION="$(sh_splitarray "$(TIni.Get "$config_file" "perfil" "$key")" 6)"
	MANJARO_BRANCH="$(sh_splitarray "$(TIni.Get "$config_file" "perfil" "$key")" 7)"
	BIGLINUX_BRANCH="$(sh_splitarray "$(TIni.Get "$config_file" "perfil" "$key")" 8)"
	BIGCOMMUNITY_BRANCH="$(sh_splitarray "$(TIni.Get "$config_file" "perfil" "$key")" 9)"
	CHILILINUX_BRANCH="$(sh_splitarray "$(TIni.Get "$config_file" "perfil" "$key")" 10)"
	KERNEL="$(sh_splitarray "$(TIni.Get "$config_file" "perfil" "$key")" 11)"
	RELEASE_TAG="$(sh_splitarray "$(TIni.Get "$config_file" "perfil" "$key")" 12)"
	TMATE="$(sh_splitarray "$(TIni.Get "$config_file" "perfil" "$key")" 13)"
	DEBUG="$(sh_splitarray "$(TIni.Get "$config_file" "perfil" "$key")" 14)"
}

resume_and_build() {
	# Confirmar as escolhas
	clear
	echo "${black}$(replicate '=')${reset}"
	echo -e "${cyan}Resumo das escolhas:${reset}"
	echo "${black}$(replicate '=')${reset}"
	echo "Organization          : ${orange}$ORGANIZATION ${reset}"
	echo "Repo Workflow         : ${orange}$REPO_WORKFLOW ${reset}"
	echo "User Name             : ${orange}$GITHUB_USER_NAME ${reset}"
	echo "Distroname            : ${orange}$DISTRONAME ${reset}"
	echo "Iso Profiles repo     : ${orange}$ISO_PROFILES_REPO ${reset}"
	echo "DISTRONAME_ISOPROFILES: ${orange}$DISTRONAME_ISOPROFILES ${reset}"
	echo "Build List            : ${orange}$BUILD_DIR ${reset}"
	echo "Edition               : ${orange}$EDITION ${reset}"
	echo "Manjaro Branch        : ${orange}$MANJARO_BRANCH ${reset}"
	echo "BigLinux Branch       : ${orange}$BIGLINUX_BRANCH ${reset}"
	echo "Community Branch      : ${orange}$BIGCOMMUNITY_BRANCH ${reset}"
	echo "ChiliLinux Branch     : ${orange}$CHILILINUX_BRANCH ${reset}"
	echo "Kernel                : ${orange}$KERNEL ${reset}"
	echo "Release Tag           : ${orange}$RELEASE_TAG ${reset}"
	echo "TMATE Debug           : ${orange}$TMATE ${reset}"
	echo "BASH Debug            : ${orange}$DEBUG ${reset}"
	echo "${black}$(replicate '=')${reset}"

	if $IS_ADD_PERFIL; then
		if conf "${YELLOW}Deseja gravar o perfil?"; then
			local get_perfil_name
			local def_perfil_name="$DISTRONAME-$EDITION-$KERNEL"
			local nRow=21

			while true; do
				setpos $nRow 0
				replicate " "
				printpos $nRow 0 "Nome do perfil [ ] : $def_perfil_name"
				get $nRow 0 "Nome do perfil [ ] : " get_perfil_name "$def_perfil_name"
				if [[ -z "$get_perfil_name" ]]; then
					errorbeep
					printpos $nRow 15 "${CROSS}"
					setpos $nRow 21
					if ! conf "${red}Nome do perfil não pode ser em branco. Tentar novamente?${rst}"; then
						echo
						die "Nome do perfil não pode ser em branco."
					fi
					continue
				fi
				break
			done
			printpos $nRow 15 "${TICK}"

			last_key=$(TIni.Get "$config_file" "perfil" 'keys')
			((last_key++))
			perfil_data="$get_perfil_name|"
			perfil_data+="$DISTRONAME|"
			perfil_data+="$ISO_PROFILES_REPO|"
			perfil_data+="$DISTRONAME_ISOPROFILES|"
			perfil_data+="$BUILD_DIR|"
			perfil_data+="$EDITION|"
			perfil_data+="$MANJARO_BRANCH|"
			perfil_data+="$BIGLINUX_BRANCH|"
			perfil_data+="$BIGCOMMUNITY_BRANCH|"
			perfil_data+="$CHILILINUX_BRANCH|"
			perfil_data+="$KERNEL|"
			perfil_data+="$RELEASE_TAG|"
			perfil_data+="$TMATE|"
			perfil_data+="$DEBUG"
			TIni.Set "$config_file" "perfil" "$last_key" "$perfil_data"
			TIni.Set "$config_file" "perfil" "keys" "$last_key"
			setpos $((nRow + 1)) 0
			msg_ok "Perfil adicionado com sucesso!"
		fi
		exit 0
	fi

	if ! conf "${YELLOW}Deseja prosseguir com a construção da ISO?"; then
		die "${RED}" "Construção da ISO cancelada."
	fi
}

printpos() {
	local row="$1"
	local col="$2"
	local msg="$3"
	local color="${4:-${Acores[box]}}"

	setpos "$row" "$col"
	printf "${color}${msg}"
}

setpos() {
	local row="$1"
	local col="$2"

	Prow="$row"
	Pcol="$col"
	# tput cup "$row" "$col"
	printf "\e[$((row + 1));$((col + 1))H"
}

get() {
	local row="$1"
	local col="$2"
	local prompt="$3"
	local new_value="$4"
	local old_value="$5"
	local color="${6:-$white}"

	setpos "$row" "$col"
	printf "%s" "${reset}$color"
	#read -r -p "${prompt}${reverse}" -e -i "$old_value" "$new_value"
	read -r -p "${prompt}" -e -i "$old_value" "$new_value"
	tput sc # Salva a posição atual do cursor
	echo -e "$reset"
}

# Função para remover uma chave de um arquivo de configuração INI
TIni.Remove() { TIni.Delete "$@"; }
TIni.Delete() {
	local config_file="$1"
	local section="$2"
	local key="$3"

	# Verifica se o arquivo de configuração existe
	if [ ! -f "$config_file" ]; then
		return 2
	fi

	# Usa sed para remover a chave do arquivo de configuração
	sed -i "/^\[$section\]/,/^$/ { /^\s*$key\s*=/d }" "$config_file"
}
export -f TIni.Delete
export -f TIni.Remove

TIni.RemoveAndReindex() {
	local config_file="$1"
	local section="$2"
	local key="$3"

	awk -v key="$key" -v section="[$section]" '
    BEGIN { dentro_sessao = 0; n = 1; total = 0 }
    $0 == section { dentro_sessao = 1; print; next }  # Identifica a seção correta
    /^\[/ && $0 != section { dentro_sessao = 0 }  # Sai da seção ao encontrar outra
    dentro_sessao && /^keys=/ { total = $2; next }  # Captura o total de chaves e ignora a linha para recalculá-la depois
    dentro_sessao && /^[0-9]+=/ {
      split($1, arr, "=")
      if (arr[1] != key) {
        printf "%d=%s\n", n++, substr($0, index($0, "=") + 1)
      }
      next
    }
    { print }  # Mantém todas as outras linhas intactas
    END {
      if (dentro_sessao) print "keys=" (n-1)  # Atualiza keys= com o número correto de chaves
    }
  ' "$config_file" | tee "$config_file.tmp" >/dev/null && mv "$config_file.tmp" "$config_file"
}
export -f TIni.RemoveAndReindex

TIni.Get() {
	local config_file="$1"
	local section="$2"
	local key="$3"

	[[ ! -e "$config_file" ]] && echo "" >"$config_file"
	sed -nr "/^\[$section\]/ { :l /^[[:space:]]*${key}[[:space:]]*=/ { s/[^=]*=[[:space:]]*//; p; q;}; /^;/b; n; b l;}" "$config_file"
}
export -f TIni.Get

# TIni.Set "config.ini" "App" "versao" "2.0"
TIni.Set() {
	local config_file="$1"
	local section="$2"
	local key="$3"
	local new_value="$4"
	local ident_keys=1

	declare -A ini_data # Array associativo para armazenar as seções e chaves

	if [[ -r "$config_file" ]]; then
		# Ler o arquivo INI e armazenar as informações em um array associativo
		local current_section=""
		while IFS= read -r line; do
			if [[ "$line" =~ ^\[(.*)\] ]]; then
				current_section="${BASH_REMATCH[1]}"
			elif [[ "$line" =~ ^([^=]+)=(.*) ]]; then
				local current_key="${BASH_REMATCH[1]}"
				local current_value="${BASH_REMATCH[2]}"
				ini_data["$current_section,$current_key"]="$current_value"
			fi
		done <"$config_file"
	fi

	# Atualizar o valor no array associativo
	ini_data["$section,$key"]="$new_value"

	# Reescrever o arquivo INI com as seções e chaves atualizadas
	echo "" >"$config_file"
	local current_section=""
	for section_key in "${!ini_data[@]}"; do
		local section_name="${section_key%,*}"
		local key_name="${section_key#*,}"
		local value="${ini_data[$section_key]}"

		# Verifique se a seção já foi gravada
		if [[ "$current_section" != "$section_name" ]]; then
			echo "" >>"$config_file"
			echo "[$section_name]" >>"$config_file"
			current_section="$section_name"
		fi
		echo "$key_name=$value" >>"$config_file"
	done
	# TIni.AlignAllSections "$config_file"
	# big-tini-pretty -q "$config_file"
	TIni.Sanitize "$config_file"
}
export -f TIni.Set

TIni.Sanitize() {
	local ini_file="$1"
	local tempfile1
	local tempfile2

	# Criar arquivos temporários
	tempfile1=$(mktemp)
	tempfile2=$(mktemp)

	# Remover linhas em branco do arquivo original
	sed '/^$/d' "$ini_file" >"$tempfile1"

	# Consolidar seções usando awk e salvar no segundo arquivo temporário
	awk '
  BEGIN {
      section = ""
  }
  {
      if ($0 ~ /^\[.*\]$/) {
          section = $0
      } else if (section != "") {
          sections[section] = sections[section] "\n" $0
      }
  }
  END {
    for (section in sections) {
        print section sections[section] "\n"
    }
  }
  ' "$tempfile1" >"$tempfile2"

	sed '/^\s*$/d' "$tempfile2" >"$ini_file"

	# colocar uma linha em branco entre as sessoes e remover a primeira linha em branco
	sed -i -e '/^\[/s/\[/\n&/' -e '1{/^[[:space:]]*$/d}' "$ini_file"
	sed -i -e '1{/^[[:space:]]*$/d}' "$ini_file"

	# marcar como executável
	chmod +x "$ini_file"

	# Remover arquivos temporários
	rm "$tempfile1" "$tempfile2"
}
export -f TIni.Sanitize

TIni.Clean() {
	local ini_file="$1"

	sed -i -e '/./,$!d' -e 's/[ \t]*=[ \t]*/=/' "$ini_file"
	# awk -F'=' '{
	#   gsub(/^[ \t]+|[ \t]+$/, "", $1);
	#   gsub(/^[ \t]+|[ \t]+$/, "", $2);
	#   print $1 "=" $2
	# }' "$ini_file" | tee "$ini_file"

}
export -f TIni.Clean

sh_splitarray() {
	local str=("$1")
	local pos="$2"
	local sep="${3:-'|'}"
	local array

	[[ $# -eq 3 && "$pos" = "|" && "$sep" =~ ^[0-9]+$ ]] && {
		sep="$2"
		pos="$3"
	}
	[[ $# -eq 2 && "$pos" = "$sep" ]] && {
		sep="$pos"
		pos=1
	}
	[[ $# -eq 1 || ! "$pos" =~ ^[0-9]+$ ]] && { pos=1; }

	IFS="$sep" read -r -a array <<<"$str"
	echo "${array[pos - 1]}"
}

repo_exists() {
	local user_or_org="$1"
	local repo="$2"

	local url="https://api.github.com/repos/${user_or_org}/${repo}"
	local status_code=$(curl -s -o /dev/null -w "%{http_code}" "$url")

	if [[ "$status_code" == "200" ]]; then
		return 0
	else
		return 1
	fi
}

sh_read_custom_repositorys() {
	local last_key=$(TIni.Get "$config_file" "custom-repositorys" 'keys')
	local custom_url=()

	if [[ ! -z "$last_key" ]]; then
		for ((i = 1; i <= last_key; i++)); do
			custom_url=($(TIni.Get "$config_file" "custom-repositorys" "$i"))
			result_url=$(sh_splitarray "${custom_url}" 1)
			result_api=$(sh_splitarray "${custom_url}" 2)
			aProfiles+=($result_url)
			ApiProfiles+=([$result_url]=$result_api)
		done
	fi
}

sh_custom_repo_exist_and_print() {
	local url="$1"
	awk -F= -v val="$url" '
    BEGIN { found=1 }
    /^\[custom-repositorys\]/ { inside=1; next }
    /^\[/ { inside=0 }
    inside && $2 ~ val { print $0; found=0 }
    END { exit found }
  ' $config_file
}

sh_custom_repo_exist() {
	local url="$1"
	awk -F= -v val="$url" '
    BEGIN { found=1 }
    /^\[custom-repositorys\]/ { inside=1; next }
    /^\[/ { inside=0 }
    inside && $2 ~ val { found=0; exit }
    END { exit found }
  ' "$config_file"
}

sh_add_iso_profiles() {
	local get_user_repo
	local get_name_repo
	local def_user_repo=""
	local def_name_repo="iso-profiles"
	local last_key
	local nRow=9

	while true; do
		clear
		configure_base_vars
		sh_show_is_build_iso
		echo -e "${BLUE}${BOLD}${ccabec}${rst}"
		echo -e "${BLUE}${BOLD}Entre com o usuario e nome do repositório do iso-profiles no Github:${rst}\n"

		printpos $((nRow + 0)) 0 "Github Usuario Repositorio [ ] : $def_user_repo"
		printpos $((nRow + 1)) 0 "Github Nome Repositorio    [ ] : $def_name_repo"
		get $((nRow + 0)) 0 "Github Usuario Repositorio [ ] : " get_user_repo "$def_user_repo"
		if [[ -z "$get_user_repo" ]]; then
			errorbeep
			printpos $((nRow + 0)) 27 "${CROSS}"
			setpos $((nRow + 0)) 33
			if ! conf "${red}Usuário do repositorio não pode ser em branco. Tentar novamente?${rst}"; then
				echo
				die "Usuário Repositorio não pode ser em branco."
			fi
			continue
		fi
		printpos $((nRow + 0)) 27 "${TICK}"

		get $((nRow + 1)) 0 "Github Nome Repositorio    [ ] : " get_name_repo "$def_name_repo"
		if [[ -z "$get_name_repo" ]]; then
			errorbeep
			printpos $((nRow + 1)) 27 "${CROSS}"
			setpos $((nRow + 1)) 33
			if ! conf "${red}Nome Repositorio não pode ser em branco. Tentar novamente?${rst}"; then
				echo
				die "Nome Repositorio não pode ser em branco."
			fi
			continue
		fi
		printpos $((nRow + 1)) 27 "${TICK}"

		full_url="https://github.com/${get_user_repo}/${get_name_repo}"
		full_url_api="https://api.github.com/repos/${get_user_repo}/${get_name_repo}/contents/"

		if sh_custom_repo_exist "$full_url"; then
			setpos $((nRow + 2)) 33
			if ! conf "${red}Repositório já existe no arquivo. Tentar novamente?${rst}"; then
				echo
				die "Repositório já existe no arquivo"
			fi
			continue
		fi

		setpos $((nRow + 2)) 0
		msg "Aguarde, checando a existência do repositório ==> $full_url ..."
		if ! repo_exists "$get_user_repo" "$get_name_repo"; then
			setpos $((nRow + 2)) 0
			replicate " "
			printpos $((nRow + 1)) 27 "${CROSS}"
			setpos $((nRow + 2)) 33
			if ! conf "${red}Usuario ou nome repositorio não localizado no Github. Tentar novamente?${rst}"; then
				echo
				die "Usuario ou nome repositorio inválido."
			fi
		fi

		setpos $((nRow + 2)) 0
		replicate " "
		setpos $((nRow + 2)) 33
		if conf "${YELLOW}Deseja gravar o profile?"; then
			last_key=$(TIni.Get "$config_file" "custom-repositorys" 'keys')
			((last_key++))
			TIni.Set "$config_file" "custom-repositorys" "$last_key" "$full_url|$full_url_api"
			TIni.Set "$config_file" "custom-repositorys" "keys" "$last_key"
			msg_ok "Profile adicionado com sucesso!"
		fi
		exit 0
	done
}

get_distroname() {
	create_menu_with_array "Escolha nome da ${yellow}DISTRIBUIÇÃO:" aDistros[@] "$DISTRONAME"
	if [[ $MENU_RESULT == "Sair" ]]; then
		die "${red}" "Construção da ISO cancelada.${reset}"
	fi
	DISTRONAME="${MENU_RESULT}"
}

get_edition() {
	local repo="$1"
	local dir="$2"
	local api_url="${ApiProfiles[$repo]}"
	local response

	# Verifica se o repositório existe no array
	if [[ -z "$api_url" ]]; then
		die "${red}" "Erro: Repositório não encontrado no array: $repo ${reset}"
	fi

	# Se for GitHub, faz a requisição
	if [[ "$api_url" == *"github"* ]]; then
		# Faz a requisição para o GitHub
		p_log "${CYAN}" "Fazendo requisição na API $api_url {NC}"
		response=$(curl -sL "${api_url}${dir}")

		# Verifica se a resposta está vazia ou se ocorreu erro
		if [[ -z "$response" || "$response" == *"404 Not Found"* ]]; then
			die "${red}" "Erro: Problema ao acessar o diretório: $dir ${reset}"
		fi

		# Processamento para GitHub
		mapfile -t subdirs < <(
			echo "$response" |
				jq -r '.[] | select(.type == "dir") | .name'
		)
	elif [[ "$api_url" == *"gitlab"* ]]; then
		# Faz a requisição para o GitLab com o parâmetro 'path'
		p_log "${CYAN}" "Fazendo requisição na API $api_url {NC}"
		response=$(curl -sL "${api_url}?path=${dir}")

		# Verifica se a resposta está vazia ou se ocorreu erro
		if [[ -z "$response" || "$response" == *"404 Not Found"* ]]; then
			die "${red}" "Erro: Problema ao acessar o repositório: $repo ${reset}"
		fi

		# Processamento para GitLab
		# Filtra os diretórios e pega o nome de cada um, excluindo os indesejados
		mapfile -t subdirs < <(
			echo "$response" |
				jq -r '.[] | select(.type == "tree") | .name' |
				grep -vE '^(shared|grub|temp_repo|.github)$'
		)
	else
		die "${red}" "Erro: Repositório desconhecido ${reset}"
	fi

	# Adiciona a opção "Sair"
	subdirs+=("Sair")

	# Cria o menu com as edições encontradas
	create_menu_with_array "Escolha uma ${yellow}EDIÇÃO/DE${reset} para o ${yellow}${DISTRONAME}${reset}:" subdirs[@] "$EDITION"
	if [[ $MENU_RESULT == "Sair" ]]; then
		die "${red}" "Construção da ISO cancelada.${reset}"
	fi
	EDITION="${MENU_RESULT}"
}

get_iso_profiles_repo() {
	# Gerando a URL padrão com base no valor de $DISTRONAME
	local default_url="https://github.com/$DISTRONAME/iso-profiles"
	create_menu_with_array "Escolha o repositório ${yellow}ISO-PROFILES ${reset}para ${yellow}$DISTRONAME:" aProfiles[@] "$default_url"
	if [[ $MENU_RESULT == "Sair" ]]; then
		die "${red}" "Construção da ISO cancelada. ${reset}"
	fi
	ISO_PROFILES_REPO="${MENU_RESULT}"
}

get_build_list() {
	local repo="$1"
	local api_url="${ApiProfiles[$repo]}"
	local response

	# Verifica se o repositório existe no array
	if [[ -z "$api_url" ]]; then
		die "${red}" "Erro: Repositório não encontrado no array: $repo ${reset}"
	fi

	# Faz a requisição e inspeciona a resposta para entender o formato
	#	p_log "${cyan}" "Fazendo requisição na API $api_url ${reset}"
	response=$(curl -sL "$api_url")

	# Verifica se a resposta está vazia ou se ocorreu um erro 404
	if [[ -z "$response" || "$response" == *"404 Not Found"* ]]; then
		die "${red}" "Erro: Repositório não encontrado ou erro ao acessar a URL: $repo ${reset}"
	fi

	# Se o repositório for do GitHub, a estrutura de resposta é diferente
	if [[ "$api_url" == *"github"* ]]; then
		# Processa a resposta para GitHub
		mapfile -t build_list < <(
			echo "$response" |
				jq -r '.[] | select(.type == "dir") | .name' |
				grep -vE '^(shared|grub|temp_repo|.github)$'
		)
	else
		# Processa a resposta para GitLab
		mapfile -t build_list < <(
			echo "$response" |
				jq -r '.[] | select(.type == "tree") | .name' |
				grep -vE '^(shared|grub|temp_repo|.github)$'
		)
	fi

	build_list+=("Sair")
	create_menu_with_array "Escolha uma ${yellow}BUILD_LIST${reset} para o ${yellow}${DISTRONAME}${reset}:" build_list[@] "$DISTRONAME"
	if [[ $MENU_RESULT == "Sair" ]]; then
		die "${red}" "Construção da ISO cancelada.${reset}"
	fi
	BUILD_DIR="${MENU_RESULT}"
}

get_manjaro_branch() {
	create_menu_with_array "Escolha uma opcao para Branch do ${yellow}Manjaro${reset}:" aBranchs[@] 'stable'
	# Verifica se a opção selecionada foi "Sair"
	if [[ $MENU_RESULT == "Sair" ]]; then
		die "${red}" "Construção da ISO cancelada.${reset}"
	fi
	MANJARO_BRANCH="${MENU_RESULT}"
}

get_biglinux_branch() {
	create_menu_with_array "Escolha uma opcao para Branch do ${yellow}BigLinux${reset}:" aBranchs[@] 'stable'
	# Verifica se a opção selecionada foi "Sair"
	if [[ $MENU_RESULT == "Sair" ]]; then
		die "${red}" "Construção da ISO cancelada.${reset}"
	fi
	BIGLINUX_BRANCH="${MENU_RESULT}"
}

get_bigcommunity_branch() {
	create_menu_with_array "Escolha uma opcao para Branch do ${yellow}BigCommunity${reset}:" aBranchs[@] 'stable'
	# Verifica se a opção selecionada foi "Sair"
	if [[ $MENU_RESULT == "Sair" ]]; then
		die "${red}" "Construção da ISO cancelada.${reset}"
	fi
	BIGCOMMUNITY_BRANCH="${MENU_RESULT}"
}

get_chililinux_branch() {
	create_menu_with_array "Escolha uma opcao para Branch do ${yellow}ChiliLinux${reset}:" aBranchs[@] 'stable'
	# Verifica se a opção selecionada foi "Sair"
	if [[ $MENU_RESULT == "Sair" ]]; then
		die "${red}" "Construção da ISO cancelada.${reset}"
	fi
	CHILILINUX_BRANCH="${MENU_RESULT}"
}

get_kernel() {
	create_menu_with_array "Escolha a versão do ${yellow}KERNEL${reset}:" aKernels[@] "$KERNEL"
	# Verifica se a opção selecionada foi "Sair"
	if [[ $MENU_RESULT == "Sair" ]]; then
		die "${red}" "Construção da ISO cancelada.${reset}"
	fi
	KERNEL="${MENU_RESULT}"
}

get_debug() {
	local -a aDebug=('Não' 'Sim' 'Sair')
	create_menu_with_array "Ativar sessão de debug TMATE?" aDebug[@] "$TMATE"
	# Verifica se a opção selecionada foi "Sair"
	if [[ $MENU_RESULT == "Sair" ]]; then
		die "${red}" "Construção da ISO cancelada.${reset}"
	fi
	DEBUG=$([ "$MENU_RESULT" == "Sim" ] && echo "true" || echo "false")
	TMATE=$([ "$MENU_RESULT" == "Sim" ] && echo "true" || echo "false")
}

get_distroname_isoprofiles() {
	# Extraindo a organização
	if [[ $ISO_PROFILES_REPO == 'https://gitlab.manjaro.org/profiles-and-settings/iso-profiles.git' ]]; then
		DISTRONAME_ISOPROFILES="${DISTRONAME}"
	elif [[ $ISO_PROFILES_REPO == 'https://github.com/communitybig/iso-profiles' ]]; then
		DISTRONAME_ISOPROFILES='bigcommunity'
	else
		if [[ $ISO_PROFILES_REPO =~ https?://[^/]+/([^/]+)/.* ]]; then
			DISTRONAME_ISOPROFILES="${BASH_REMATCH[1]}"
		else
			DISTRONAME_ISOPROFILES="${DISTRONAME}"
		fi
	fi
	echo "$DISTRONAME_ISOPROFILES"
}

set_varcolors() {
	# does the terminal support true-color?
	if [[ -n "$(command -v "tput")" ]]; then
		#tput setaf 127 | cat -v  #capturar saida
		: "${RED=$(tput bold)$(tput setaf 196)}"
		: "${GREEN=$(tput bold)$(tput setaf 2)}"
		: "${YELLOW=$(tput bold)$(tput setaf 3)}"
		: "${BLUE=$(tput setaf 4)}"
		: "${PURPLE=$(tput setaf 125)}"
		: "${CYAN=$(tput setaf 6)}"
		: "${NC=$(tput sgr0)}"
		: "${RESET=$(tput sgr0)}"
		: "${BOLD=$(tput bold)}"
		: "${black=$(tput bold)$(tput setaf 0)}"
		: "${branca=${black}$(tput setab 7)}"

		: "${reset=$(tput sgr0)}"
		: "${rst=$(tput sgr0)}"
		: "${bold=$(tput bold)}"
		: "${underline=$(tput smul)}"
		: "${nounderline=$(tput rmul)}"
		: "${reverse=$(tput rev)}"

		: "${black=$(tput bold)$(tput setaf 0)}"
		: "${red=$(tput bold)$(tput setaf 196)}"
		: "${green=$(tput bold)$(tput setaf 2)}"
		: "${yellow=$(tput bold)$(tput setaf 3)}"
		: "${blue=$(tput setaf 27)}"
		: "${magenta=$(tput setaf 5)}"
		: "${cyan=$(tput setaf 6)}"
		: "${white=$(tput setaf 7)}"
		: "${gray=$(tput setaf 8)}"
		: "${light_red=$(tput setaf 9)}"
		: "${light_green=$(tput setaf 10)}"
		: "${light_yellow=$(tput setaf 11)}"
		: "${light_blue=$(tput setaf 12)}"
		: "${light_magenta=$(tput setaf 13)}"
		: "${light_cyan=$(tput setaf 14)}"
		: "${light_white=$(tput setaf 15)}"
		: "${orange=$(tput setaf 202)}"
		: "${purple=$(tput setaf 125)}"
		: "${violet=$(tput setaf 61)}"

		# Definir cores de fundo
		: "${preto=$(tput setab 0)}"
		: "${vermelho=$(tput setab 196)}"
		: "${verde=$(tput setab 2)}"
		: "${amarelo=$(tput setab 3)}"
		: "${azul=$(tput setab 20)}"
		: "${roxo=$(tput setab 5)}"
		: "${ciano=$(tput setab 6)}"
		: "${branca="${black}$(tput setab 7)"}"
		: "${cinza=$(tput setab 8)}"
		: "${laranja=$(tput setab 202)}"
		: "${roxa=$(tput setab 125)}"
		: "${violeta=$(tput setab 61)}"

		: "${COL_NC='\e[0m'}" # No Color
		: "${COL_LIGHT_GREEN='\e[1;32m'}"
		: "${COL_LIGHT_RED='\e[1;31m'}"
		: "${DONE="${COL_LIGHT_GREEN} done!${COL_NC}"}"
		: "${OVER="\\r\\033[K"}"
		: "${DOTPREFIX="  ${black}::${reset} "}"
		: "${TICK="${white}[${green}✓${rst}${white}]${rst}"}"
		: "${CROSS="${white}[${red}✗${rst}${white}]${rst}"}"
		: "${INFO="${white}[${gray}i${rst}${white}]${rst}"}"
	else
		unset_varcolors
	fi
}

unset_varcolors() {
	unset RED GREEN YELLOW BLUE PURPLE CYAN NC RESET BOLD
	unset reset rst bold underline nounderline reverse
	unset black red green yellow blue magenta cyan white gray orange purple violet
	unset light_red light_green light_yellow light_blue light_magenta light_cyan light_white
	unset preto vermelho verde amarelo azul roxo ciano branca cinza laranja roxa violeta
	: "${COL_NC='\e[0m'}" # No Color
	: "${COL_LIGHT_GREEN='\e[1;32m'}"
	: "${COL_LIGHT_RED='\e[1;31m'}"
	: "${DONE="${COL_LIGHT_GREEN} done!${COL_NC}"}"
	: "${OVER="\\r\\033[K"}"
	: "${DOTPREFIX="  ${black}::${reset} "}"
	: "${TICK="${white}[${green}✓${rst}${white}]${rst}"}"
	: "${CROSS="${white}[${red}✗${rst}${white}]${rst}"}"
	: "${INFO="${white}[${gray}i${rst}${white}]${rst}"}"
}

#funcao_A() { return; }
#funcao_B() { return; }
#funcao_C() { return; }
#
#switch_to_root() {
#	# Verifica se o usuário não é root
#	if [ "$EUID" -ne 0 ]; then
#		echo "Elevando privilégios para root..."
#		sudo bash -c "$(declare -f funcao_A); $(declare -f funcao_B); $(declare -f funcao_C); funcao_A"
#	else
#		funcao_A
#	fi
#}

print() {
	local msg="$1"
	echo -e "${msg}"
}

msg() {
	local msg="$1"
	echo -e "mkiso-build=>${cyan}running: ${yellow}${msg}${reset}"
}

msg_info() {
	local msg="$1"
	echo -e "mkiso-build=>${yellow}info   : ${cyan}${msg}${reset}"
}

msg_sub() {
	local msg="$1"
	echo -e "               >${green}${msg}${reset}"
}

msg_raw() {
	local msg="$1"
	# Remove tags HTML, se existirem
	#msg="$(sed 's/<[^>]*>//g' <<< "$msg")"

	# Verifica se existe ':' na mensagem
	if [[ "$msg" == *:* ]]; then
		# Divide a string antes e depois do primeiro ':'
		local before_colon="${msg%%:*}:"
		local after_colon="${msg#*: }"
		# Aplica as cores
		msg="${cyan}${before_colon} ${yellow}${after_colon}${reset}"
	else
		# Se não houver ':', aplica apenas a cor padrão
		msg="${cyan}${msg}${reset}"
	fi
	echo -e "$msg"
}
export -f msg_raw

msg_warning() {
	local msg="$1"
	echo -e "mkiso-build=>${red}warning: ${orange}${msg}${reset}"
}

msg_ok() {
	local msg="$1"
	printf "==>%b%-10s%s\n" "${green}" "[FEITO]" "${green}$msg${reset}"
}
export -f msg_ok

p_log() {
	local color="$1"
	local message="$2"
	local died="$3"

	[[ -z "$died" ]] && died=false
	# echo -e "${color}=> ${message}${reset}"
	if $died; then
		printf "${CROSS} mkiso-build=>${red}Error: ${color}%s\n\033[m" "$message"
	else
		printf "${TICK} mkiso-build=> ${color}%s\n\033[m" "$message"
	fi
	# Remover códigos de escape ANSI do log
	#clean_log=$(sed -E 's/\x1b\[[0-9;]*[a-zA-Z]//g; s/\x1b\(B//g' <<<"$message")
	#echo "[$(date '+%Y-%m-%d %H:%M:%S')] ${clean_log}" >>"${LOG_FILE}"
}

errorbeep() {
	printf '\a' # beep
}

# Funções auxiliares
conf() {
	read -r -p "$1 [S/n]"
	[[ ${REPLY^} == "" ]] && return 0
	[[ ${REPLY^} == N ]] && return 1 || return 0
}

die() {
	local color="$1"
	local message="$2"
	p_log "$color" "$message" true
	exit 1
}

replicate() {
	local char=${1:-'#'}
	local nsize=${2:-$(tput cols)}
	local line
	printf -v line "%*s" "$nsize" && echo "${line// /$char}"
}
export -f replicate

sh_version() {
	cat <<-EOF_VERSION
		${bold}${cyan}${0##*/} v${VERSION}${reset}
		${APPDESC}
		${bold}${black}Copyright (c) 2024-2024, ${reset}Vilmar Catafesta <vcatafesta@gmail.com>${black}
		${bold}${black}Copyright (C) 2024-2024, ${reset}BigCommunity Team${black}

		  Este é um software livre: você é livre para alterá-lo e redistribuí-lo.
		  O $APP é disponibilizado para você sob a ${yellow}Licença MIT${black}, e
		  inclui software de código aberto sob uma variedade de outras licenças.
		  Você pode ler instruções sobre como baixar e criar para você mesmo
		  o código fonte específico usado para criar esta cópia.
		  ${red}Este programa vem com absolutamente NENHUMA garantia.${reset}
	EOF_VERSION
}

# Função para exibir informações de ajuda
sh_usage() {
	cat <<-EOF_USAGE
		    ${reset}${APP} v${VERSION} - ${APPDESC}${reset}
		    ${red}Uso: ${reset}$APP ${cyan}[opções]${reset}

		    ${cyan}Opções:${reset}
		      -a|--auto|--automatic          ${cyan} # Construir ISO pelo Github Actions. ${yellow}NÃO usar localmente! ${reset}
		      -m|--manual|--standalone       ${cyan} # Construir ISO localmente escolhendo manualmente os parâmetros${reset}
		      -d|--defa|--default ${orange}<perfil>   ${cyan} # Construir ISO localmente com parâmetros do ${orange}<perfil> ${rst}
		      -i|--iso-profiles              ${cyan} # Adicionar repositorio iso-profiles customizado do Github ${reset}
		      -c|--create_perfil             ${cyan} # Adicionar perfil customizado de ISO${reset}
		      -g|--get_perfil                ${cyan} # Selecionar perfil customizado de ISO${reset}
		      -l|--list_perfil               ${cyan} # Listar perfils customizado de ISO${reset}
		      -r|--remove_perfil             ${cyan} # Remove perfil customizado de ISO${reset}
		      -n|--nocolor                   ${cyan} # Suprimir impressão de cores ${reset}
		      -V|--version                   ${cyan} # Imprimir versão do aplicativo ${reset}
		      -h|--help                      ${cyan} # Exibir este Help ${reset}
	EOF_USAGE
}

sh_show_is_build_iso() {
	setpos 0 0
	echo '---------------------------------------------------------------------------------'
	msg_info "Organization       : ${color}$ORGANIZATION${rst}"
	msg_info "Repo Workflow      : ${color}$REPO_WORKFLOW${rst}"
	msg_info "User Name          : ${color}$GITHUB_USER_NAME${rst}"
	msg_info "Local Path         : ${color}$REPO_PATH${rst}"
	echo '---------------------------------------------------------------------------------'
}

sh_showchoices() {
	local color="${green}"
	#	tput clear # Limpa a tela
	if $IS_BUILD_ISO || $IS_ADD_PERFIL; then
		sh_show_is_build_iso
	fi
	if $IS_BUILD_ISO_RESUME; then
		msg_info "DISTRONAME         : ${color}$DISTRONAME${rst}"
		msg_info "ISO_PROFILES       : ${color}$ISO_PROFILES_REPO${rst}"
		msg_info "BUILD_LIST         : ${color}$BUILD_DIR${rst}"
		msg_info "EDITION            : ${color}$EDITION${reset}"
		msg_info "DISTRONAME_PROFILES: ${color}$DISTRONAME_ISOPROFILES${rst}"
		msg_info "MANJARO_BRANCH     : ${color}$MANJARO_BRANCH${rst}"
		msg_info "BIGLINUX_BRANCH    : ${color}$BIGLINUX_BRANCH${rst}"
		msg_info "BIGCOMMUNITY_BRANCH: ${color}$BIGCOMMUNITY_BRANCH${rst}"
		msg_info "CHILILINUX_BRANCH  : ${color}$CHILILINUX_BRANCH${rst}"
		msg_info "KERNEL             : ${color}$KERNEL${rst}"
		msg_info "Release Tag        : ${color}$RELEASE_TAG${rst}"
		msg_info "TMATE Debug        : ${color}$TMATE${rst}"
		msg_info "BASH Debug         : ${color}$DEBUG${rst}"
		echo '---------------------------------------------------------------------------------'
	fi
	echo -e "${BLUE}${BOLD}$ccabec${rst}"
	echo -e "${BLUE}${BOLD}$title${rst}\n"
}

create_menu_with_array() {
	local title=$1
	local -a options=("${!2}") # Recebe o array de opções
	local default=${3:-}       # Opção padrão, se fornecida
	local selected=0
	local key

	# Define a opção padrão como selecionada inicialmente
	if [[ -n "$default" ]]; then
		for i in "${!options[@]}"; do
			if [[ "${options[$i]}" == "$default" ]]; then
				selected=$i
				break
			fi
		done
	fi

	tput civis # Esconde o cursor
	tput clear # Limpa a tela

	while true; do
		sh_showchoices
		for i in "${!options[@]}"; do
			if [[ "$i" -eq $selected ]]; then
				if [[ "${options[$i]}" =~ ^(Sair|Voltar)$ ]]; then
					if [[ "$ORGANIZATION" =~ ^(chililinux|vcatafesta)$ ]]; then
						echo -e "${RED}${BOLD}${reverse}> ${options[$i]}${NC}"
					else
						echo -e "${RED}${BOLD}> ${options[$i]}${NC}"
					fi
				else
					if [[ "$ORGANIZATION" =~ ^(chililinux|vcatafesta)$ ]]; then
						echo -e "${GREEN}${BOLD}${reverse}> ${options[$i]}${NC}"
					else
						echo -e "${GREEN}${BOLD}> ${options[$i]}${NC}"
					fi
				fi
			else
				if [[ "${options[$i]}" =~ ^(Sair|Voltar)$ ]]; then
					echo -e "${RED}  ${options[$i]}${NC}"
				else
					echo "  ${options[$i]}"
				fi
			fi
		done

		read -rsn1 key
		case "$key" in
		A)
			((selected--))
			[ $selected -lt 0 ] && selected=$((${#options[@]} - 1))
			;;
		B)
			((selected++))
			[ $selected -eq ${#options[@]} ] && selected=0
			;;
		'') break ;;
		esac
	done

	tput cnorm # Mostra o cursor novamente
	echo -e "\nVocê selecionou: ${GREEN}${BOLD}${options[$selected]}${NC}"
	MENU_RESULT=${options[$selected]}
	#	return $((selected+1))
}

sh_time_elapsed() {
	local end_time
	local duration
	local hours
	local minutes
	local seconds

	end_time=$(date +%s)                # Obtém o tempo de término em segundos desde a época Unix
	duration=$((end_time - start_time)) # Calcula a duração em segundos
	hours=$((duration / 3600))
	minutes=$(((duration % 3600) / 60))
	seconds=$((duration % 60))

	# Formatar os valores para terem sempre dois dígitos
	hours=$(printf "%02d" $hours)
	minutes=$(printf "%02d" $minutes)
	seconds=$(printf "%02d" $seconds)
	echo "$hours:$minutes:$seconds"
}

##########################################################################################################################

#Step 0 - Setup BUILD - Checkout iso-profiles and clean directories
checkout_iso-profiles_and_clean_directories() {
	msg "Diretório atual: $PWD"

	if [[ -d "$WORK_PATH_ISO_PROFILES" ]]; then
		msg 'Mova perfis iso-profiles antigos para novo diretório'
		#if ! mv -f $WORK_PATH_ISO_PROFILES $HOME_FOLDER/iso-profiles."$(date "+%Y%m%d_%H:%M:%S")"; then
		rm -rf "$WORK_PATH_ISO_PROFILES" || true
		#fi
	fi

	msg "Fazendo checkout do repositório: $ISO_PROFILES_REPO"
	if ! git clone --depth 1 "$ISO_PROFILES_REPO" "$WORK_PATH_ISO_PROFILES" &>/dev/null; then
		msg "ERRO: Falha ao clonar o repositorio $ISO_PROFILES_REPO em $WORK_PATH_ISO_PROFILES"
		exit 1
	fi
	msg "ativando git config --global --add safe.directory into $WORK_PATH_ISO_PROFILES"
	git config --global --add safe.directory "$WORK_PATH_ISO_PROFILES" || true
}
export -f checkout_iso-profiles_and_clean_directories

cleaning_working_directories() {
	local cpath
	local path_dirs=('/__t'
		'/usr/share/manjaro-tools'
		'/usr/lib/manjaro-tools'
		'/var/lib/manjaro-tools/buildiso'
		'/var/cache/manjaro-tools/iso'
	)

	for cpath in "${path_dirs[@]}"; do
		[[ -d "$cpath" ]] && {
			msg "Limpando diretório: $cpath"
			sudo rm -rf "$cpath"/* || true
		}
	done
}

#Step 1 - Setup BUILD - check_directories_and_path
check_directories_and_path() {
	[[ ! -d "$WORK_PATH_ISO_PROFILES" ]] && {
		die "ERRO($LINENO): Diretório $WORK_PATH_ISO_PROFILES não localizado!"
	}

	# Verificando o diretório do perfil específico
	[[ ! -d "$PROFILE_PATH_EDITION" ]] && {
		die "${red}" "ERRO($LINENO): perfil $PROFILE_PATH_EDITION não encontrado!"
	}

	if $DEBUG; then
		# listando diretório iso-profiles no diretório atual
		replicate "#"
		msg_info "conteúdo path: $PROFILE_PATH"
		ls -la "$PROFILE_PATH"
		replicate "#"
		msg_info "contéudo path: $PROFILE_PATH_EDITION"
		ls -la "$PROFILE_PATH_EDITION"
		replicate "#"
		msg_info "Caminho completo do perfil: $PROFILE_PATH_EDITION"
	fi
}
export -f check_directories_and_path

#Step 2 - Setup BUILD - configurar manjaro-tools para o usuario atual
configurar_manjaro_tools_para_usuario_builduser() {
	#	if ! id "builduser" &>/dev/null; then
	#		useradd -m builduser
	#	fi

	msg "Configurando permissôes de ambiente do usuário atual ($USERNAME)"
	{
		echo 'PACKAGER="Vilmar Catafesta <vcatafesta@gmail.com>"'
		echo 'GPGKEY="A0D5A8312A83940ED8B04B0F4BAC871802E960F1"'
	} >>"$HOME_FOLDER"/.makepkg.conf

	mkdir -p "$HOME_FOLDER"/.config/manjaro-tools
	cp -R /etc/manjaro-tools "$HOME_FOLDER"/.config
	echo "run_dir=$WORK_PATH_ISO_PROFILES" >"$HOME_FOLDER"/.config/manjaro-tools/iso-profiles.conf

	msg "Ajustando permissões do usuário ($USERNAME) para o diretório de trabalho"
	chown -R "$USERNAME":"$USERNAME" "$WORK_PATH"
}
export -f configurar_manjaro_tools_para_usuario_builduser

configure_repositories_and_build_environment() {
	local conf_file

	msg 'Configurar repositórios e criar ambiente'
	msg 'Aplicando as configurações'

	[[ "$DISTRONAME" != "manjaro" ]] && {
		add_repositorys_only_install "$PATH_MANJARO_TOOLS/pacman-default.conf"
		add_repositorys_only_install "$PATH_MANJARO_TOOLS/pacman-multilib.conf"
		msg_info 'Ajustando ParallelDownloads'
		sudo sed -i 's/^\(ParallelDownloads *= *\).*/\120/' "$PATH_MANJARO_TOOLS/pacman-default.conf"
		sudo sed -i 's/^\(ParallelDownloads *= *\).*/\120/' "$PATH_MANJARO_TOOLS/pacman-multilib.conf"
	}

	conf_file="/usr/lib/manjaro-tools/util-iso-image.sh"
	if [[ -f "$conf_file" ]]; then
		msg "Alterando o path da remoção do cache de pacotes para remover '/usr/share/man'"
		msg_info "sudo sed -i 's/path=\$1\/var\/lib\/pacman\/sync/path=\$1\/usr\/share\/man/g' ${conf_file}"
		sudo sed -i 's/path=\$1\/var\/lib\/pacman\/sync/path=\$1\/usr\/share\/man/g' "${conf_file}" || {
			msg_warning "Erro ao aplicar a alteração com sed!"
		}
	else
		msg_warning "Arquivo ${conf_file} não encontrado!"
	fi

	msg 'Configurando compressão'
	# Acessa dinamicamente a variável correspondente ao DISTRONAME_BRANCH
	BRANCH_VAR="${DISTRONAME^^}_BRANCH" # Converte DISTRONAME para maiúsculas
	BRANCH="${!BRANCH_VAR}"             # Expande o valor da variável com esse nome

	conf_file="/usr/lib/manjaro-tools/util-iso.sh"
	if [[ -f "${conf_file}" ]]; then
		if [[ "$BRANCH" == "stable" ]]; then
			msg_info "sed -i 's/-Xcompression-level [0-9]\+/-Xcompression-level 22/g' ${conf_file}"
			sudo sed -i "s/-Xcompression-level [0-9]\+/-Xcompression-level 22/g" "${conf_file}" || {
				msg_warning "Erro ao aplicar a alteração com sed!"
			}
		else
			msg_info "sed -i 's/-Xcompression-level [0-9]\+/-Xcompression-level 3/g' ${conf_file}"
			sudo sed -i 's/-Xcompression-level [0-9]\+/-Xcompression-level 3/g' "${conf_flle}" || {
				msg_warning "Erro ao aplicar a alteração com sed!"
			}
		fi
		msg_info "sudo sed -i 's/256K/1024K/g' ${conf_file}"
		sudo sed -i 's/256K/1024K/g' "${conf_file}" || {
			msg_warning "Erro ao aplicar a alteração com sed!"
		}
	else
		msg_warning "Arquivo ${conf_file} não encontrado!"
	fi

	if $DEBUG; then
		replicate "#"
		msg_info "cat /etc/pacman.d/mirrorlist"
		cat /etc/pacman.d/mirrorlist || true
		replicate "#"
		msg_info "cat $PATH_MANJARO_TOOLS/pacman-default.conf"
		cat "$PATH_MANJARO_TOOLS/pacman-default.conf" || true
		replicate "#"
		msg_info "cat $PATH_MANJARO_TOOLS/pacman-multilib.conf"
		cat "$PATH_MANJARO_TOOLS/pacman-multilib.conf" || true
		replicate "#"
	fi
}
export -f configure_repositories_and_build_environment

add_iso_cleanups() {
	# cleanups
	local cleanup_script="/usr/lib/manjaro-tools/util-iso-image.sh"

	#adicionar a chamada da função iso_cleanups antes do fechamento (}) da função
	sudo sed -i '/^}/i \ \ mkiso_build_iso_cleanups "$1"' "$cleanup_script"

	#adicionar a unção iso_cleanups no fim do arquivo $cleanup_script
	#Delimitador de EOF_CLEANUPS entre aspas simples (<<-'EOF_CLEANUPS'):
	#Evita a expansão de variáveis e trata todo o conteúdo como literal.
	sudo tee -a "$cleanup_script" >/dev/null <<EOF_CLEANUPS

mkiso_build_iso_cleanups() {
  # Big cleanups
  local cpath="$1"

  # Remove documentation
  rm -rf "$cpath/usr/share/doc"/* 2> /dev/null

  # Remove man pages
  rm -rf "$cpath/usr/share/man"/* 2> /dev/null

  # Clean LibreOffice configs
  local libreoffice_path="$cpath/usr/lib/libreoffice/share/config"
  if [[ -d "$libreoffice_path" ]]; then
    rm -f "$libreoffice_path"/images_{karasa_jaga,elementary,sukapura}* 2> /dev/null
    rm -f "$libreoffice_path"/images_{colibre,sifr_dark,sifr,breeze_dark,breeze}_svg.zip 2> /dev/null
  fi

  # Clean wallpapers
  local wallpapers_path="$cpath/usr/share/wallpapers"
  if [[ -d "$wallpapers_path" ]]; then
    rm -rf "$wallpapers_path"/{Altai,BytheWater,Cascade,ColdRipple,DarkestHour,EveningGlow,Flow,FlyingKonqui,IceCold,Kokkini,Next,Opal,Patak,SafeLanding,summer_1am,Autumn,Canopee,Cluster,ColorfulCups,Elarun,FallenLeaf,Fluent,Grey,Kite,MilkyWay,OneStandsOut,PastelHills,Path,Shell,Volna}
  fi
}
export -f mkiso_build_iso_cleanups
EOF_CLEANUPS
}
export -f add_iso_cleanups

# Step 3 - Setup BUILD - configure_repositories_and_build_environment
add_biglinux-update-stable() {
	{
		echo '[biglinux-update-stable]'
		echo 'SigLevel = PackageRequired'
		echo 'Server = https://repo.biglinux.com.br/update-stable/$arch'
		echo
	}
}
export -f add_biglinux-update-stable

add_biglinux-stable() {
	{
		echo '[biglinux-stable]'
		echo 'SigLevel = PackageRequired'
		echo 'Server = https://repo.biglinux.com.br/stable/$arch'
		echo
	}
}
export -f add_biglinux-stable

add_biglinux-testing() {
	{
		echo '[biglinux-testing]'
		echo 'SigLevel = PackageRequired'
		echo 'Server = https://repo.biglinux.com.br/testing/$arch'
		echo
	}
}
export -f add_biglinux-testing

add_community-stable() {
	{
		echo '[community-stable]'
		echo 'SigLevel = PackageRequired'
		echo 'Server = https://repo.communitybig.org/stable/$arch'
		echo
	}
}
export -f add_community-stable

add_community-testing() {
	{
		echo '[community-testing]'
		echo 'SigLevel = PackageRequired'
		echo 'Server = https://repo.communitybig.org/testing/$arch'
		echo
	}
}
export -f add_community-testing

add_community-extra() {
	{
		echo '[community-extra]'
		echo 'SigLevel = PackageRequired'
		echo 'Server = https://repo.communitybig.org/extra/$arch'
		echo
	}
}
export -f add_community-extra

add_chili-stable() {
	{
		echo '[chili-stable]'
		echo 'Server = https://repo.chililinux.com/stable/$arch'
		echo 'Server = https://repo2.chililinux.com/stable/$arch'
		echo
	}
}
export -f add_chili-stable

add_chili-testing() {
	{
		echo '[chili-testing]'
		echo 'Server = https://repo.chililinux.com/testing/$arch'
		echo 'Server = https://repo2.chililinux.com/testing/$arch'
		echo
	}
}
export -f add_chili-testing

add_chili-extra() {
	{
		echo '[chili-extra]'
		echo 'Server = https://repo.chililinux.com/extra/$arch'
		echo 'Server = https://repo2.chililinux.com/extra/$arch'
		echo
		echo '[chili-aur]'
		echo 'Server = https://repo.chililinux.com/aur/$arch'
		echo 'Server = https://repo2.chililinux.com/aur/$arch'
		echo
	}
}
export -f add_chili-extra

add_chili-aur() {
	{
		echo '[chili-aur]'
		echo 'Server = https://repo.chililinux.com/aur/$arch'
		echo 'Server = https://repo2.chililinux.com/aur/$arch'
		echo
	}
}
export -f add_chili-aur

add_repositorys_only_install() {
	arquivo_conf="$1"

	if [[ "$DISTRONAME" != "manjaro" ]]; then
		# Lista de chaves a serem verificadas
		for key in biglinux-keyring community-keyring chili-keyring; do
			msg "Verificando/adicionando '$key' ao arquivo $arquivo_conf, se necessário."
			# Verifica e adiciona a chave ao SyncFirst, caso não exista
			if ! grep -q "$key" "$arquivo_conf"; then
				sudo sed -i '/SyncFirst/s/$/ "$key"/' "$arquivo_conf"
			fi
		done

		msg "Verificando se o repositório 'biglinux-update-stable' está presente no arquivo $arquivo_conf."
		# Verifica e insere o repositório antes da seção [core], se necessário
		if ! grep -q 'biglinux-update-stable' "$arquivo_conf"; then
			msg_info 'Inserindo o repositório [biglinux-update-stable] antes da seção [core]'
			sudo sed -i "/\[core\]/i \
		    [biglinux-update-stable]\
  		  \nSigLevel = PackageRequired\
	  	  \nServer = https://repo.biglinux.com.br/update-stable/\$arch\n" "$arquivo_conf"
		fi
	fi

	msg "Configurando repositórios do Manjaro"
	branch="$MANJARO_BRANCH"
	servers=('irltoolkit.mm.fcix.net'
		'mirror.fcix.net'
		'opencolo.mm.fcix.net'
		'mirrors.ocf.berkeley.edu'
		'ridgewireless.mm.fcix.net'
		'codingflyboy.mm.fcix.net'
		'mirrors.sonic.net'
		'repo.ialab.dsu.edu'
		'volico.mm.fcix.net'
		'forksystems.mm.fcix.net'
		'mnvoip.mm.fcix.net'
		'coresite.mm.fcix.net'
		'uvermont.mm.fcix.net'
		'ohioix.mm.fcix.net'
		'southfront.mm.fcix.net'
		'nnenix.mm.fcix.net'
		'mirror.math.princeton.edu'
		'mirrors.gigenet.com'
		'ask4.mm.fcix.net'
	)

	echo "Server = https://manjaro.c3sl.ufpr.br/$branch/\$repo/\$arch" | sudo tee -a "$arquivo_conf" >/dev/null
	echo "Server = https://mirror.ufam.edu.br/manjaro/$branch/\$repo/\$arch" | sudo tee -a "$arquivo_conf" >/dev/null
	echo "Server = https://linorg.usp.br/manjaro/$branch/\$repo/\$arch" | sudo tee -a "$arquivo_conf" >/dev/null

	for server in "${servers[@]}"; do
		msg_info "Incluindo $server no arquivo $arquivo_conf"
		echo "Server = https://$server/manjaro/$branch/\$repo/\$arch" | sudo tee -a "$arquivo_conf" >/dev/null
	done
	echo '' | sudo tee -a "$arquivo_conf" >/dev/null

	msg 'Configurando repositórios do BigCommunity'
	case "$BIGCOMMUNITY_BRANCH" in
	stable)
		add_community-stable | sudo tee -a "$arquivo_conf" >/dev/null
		add_community-testing | sudo tee -a "$arquivo_conf" >/dev/null
		add_community-extra | sudo tee -a "$arquivo_conf" >/dev/null
		;;
	testing | unstable)
		add_community-testing | sudo tee -a "$arquivo_conf" >/dev/null
		add_community-stable | sudo tee -a "$arquivo_conf" >/dev/null
		add_community-extra | sudo tee -a "$arquivo_conf" >/dev/null
		;;
	esac

	msg 'Configurando repositórios do ChiliLinux'
	case "$CHILILINUX_BRANCH" in
	stable)
		add_chili-stable | sudo tee -a "$arquivo_conf" >/dev/null
		add_chili-testing | sudo tee -a "$arquivo_conf" >/dev/null
		add_chili-extra | sudo tee -a "$arquivo_conf" >/dev/null
		add_community-stable | sudo tee -a "$arquivo_conf" >/dev/null
		add_community-extra | sudo tee -a "$arquivo_conf" >/dev/null
		;;
	*)
		add_chili-testing | sudo tee -a "$arquivo_conf" >/dev/null
		add_chili-stable | sudo tee -a "$arquivo_conf" >/dev/null
		add_chili-extra | sudo tee -a "$arquivo_conf" >/dev/null
		add_community-stable | sudo tee -a "$arquivo_conf" >/dev/null
		add_community-extra | sudo tee -a "$arquivo_conf" >/dev/null
		;;
	esac

	msg 'Configurando repositórios do BigLinux'
	case "$BIGLINUX_BRANCH" in
	stable)
		add_biglinux-stable | sudo tee -a "$arquivo_conf" >/dev/null
		add_biglinux-testing | sudo tee -a "$arquivo_conf" >/dev/null
		;;
	testing)
		add_biglinux-testing | sudo tee -a "$arquivo_conf" >/dev/null
		add_biglinux-stable | sudo tee -a "$arquivo_conf" >/dev/null
		;;
	esac
}
export -f add_repositorys_only_install

adjust_file() {
	local file="$1"
	local search="$2"
	local replace="$3"

	[[ -f "$file" ]] && {
		sudo sed -i "s|$search|$replace|g" "$file" || {
			msg_warning "Erro ao aplicar a alteração com sed no arquivo ${file}!"
		}
	}
}

remove_packages_from_file() {
	local remove_list="$1"
	local target_file="$2"
	[[ -f "$remove_list" && -f "$target_file" ]] || return
	while IFS= read -r package; do
		sed -i "/^$package$/d" "$target_file"
	done <"$remove_list"
}

check_internal_dependencies() {
	required_commands=("buildiso" "sudo" "sed")
	for cmd in "${required_commands[@]}"; do
		if ! command -v "$cmd" &>/dev/null; then
			die "Error: Required command '$cmd' not found." >&2
		fi
	done
	[[ -d "$WORK_PATH_ISO_PROFILES" ]] || {
		die "Error: WORK_PATH_ISO_PROFILES directory not found." >&2
	}
}

setup_manjaro_tools() {
	msg "Setting up Manjaro tools..."

	# Remover duplicatas de perfil
	[[ -d "$WORK_PATH_ISO_PROFILES/custom-profiles" ]] && {
		msg 'remover pasta para não ter duplicidade de perfil'
		msg_info "rm -rf $WORK_PATH_ISO_PROFILES/custom-profiles"
		rm -rf "$WORK_PATH_ISO_PROFILES/custom-profiles"
	}

	# Configurar diretório de cache
	msg "Criar e configurar diretórios"
	[[ ! -d "$VAR_CACHE_MANJARO_TOOLS_ISO" ]] && {
		msg_info "sudo mkdir -p $VAR_CACHE_MANJARO_TOOLS_ISO"
		sudo mkdir -p "$VAR_CACHE_MANJARO_TOOLS_ISO"
	}
	msg_info "sudo chmod 1777 $VAR_CACHE_MANJARO_TOOLS_ISO"
	sudo chmod 1777 "$VAR_CACHE_MANJARO_TOOLS_ISO"

	# Verificar dependências
	check_internal_dependencies

	msg "Ajustando 'misobasedir' no arquivo kernels.cfg em $WORK_PATH_ISO_PROFILES"
	find "$WORK_PATH_ISO_PROFILES" -name "kernels.cfg" -exec sed -i "s/misobasedir=[^ ]*/misobasedir=${DISTRONAME,,}/g" {} + || true

	msg "Ajustando 'misolabel' no arquivo kernels.cfg em $WORK_PATH_ISO_PROFILES"
	find "$WORK_PATH_ISO_PROFILES" -name "kernels.cfg" -exec sed -i "s/misolabel=[^ ]*/misolabel=${VOL_ID}/g" {} + || true

	# Substituição no arquivo variable.cfg
	msg "Ajustando 'themes' no arquivo variable.cfg em $WORK_PATH_ISO_PROFILES"
	find "$WORK_PATH_ISO_PROFILES" -name "variable.cfg" -exec sed -i \
		"s#grub_theme=/boot/grub/themes/[^/]*/theme.txt#grub_theme=/boot/grub/themes/${DISTRONAME_ISOPROFILES,,}-live/theme.txt#g" {} + || true

	# Substituição no arquivo grub.cfg
	msg "Ajustando 'themes' no arquivo grub.cfg em $WORK_PATH_ISO_PROFILES"
	find "$WORK_PATH_ISO_PROFILES/shared/live-overlay/usr/share/grub/cfg/" -name "grub.cfg" -exec sed -i \
		"s#theme=(\$root)/boot/grub/themes/[^/]*/theme.txt#theme=(\$root)/boot/grub/themes/${DISTRONAME_ISOPROFILES,,}-live/theme.txt#g" {} + || true

	msg "Ajustando o tema no arquivo '/usr/lib/manjaro-tools/util-iso-boot.sh' para usar DISTRONAME_ISOPROFILES (${DISTRONAME_ISOPROFILES,,})."
	sudo sed -i "s|\${data_live}/themes/[^ ]*-live \${grub}/themes/|\${data_live}/themes/${DISTRONAME_ISOPROFILES,,}-live \${grub}/themes/|g" /usr/lib/manjaro-tools/util-iso-boot.sh

	msg "Ajustando o memtest-ufi no arquivo '/usr/lib/manjaro-tools/util-iso-boot.sh'"
	sudo sed -i '/memtest.bin/ a\ cp $1/boot/memtest86+/memtest.efi $2/memtest-efi' /usr/lib/manjaro-tools/util-iso-boot.sh

	# Apply Custom Profile Modifications
	# Apply edition-specific removals
	for remove_file in Root-remove Live-remove Mhwd-remove Desktop-remove; do
		if [[ -f "$PROFILE_PATH_EDITION/$remove_file" ]]; then
			target_file="$PROFILE_PATH_EDITION/Packages-${remove_file%-remove}"
			if [[ -f "$target_file" ]]; then
				msg "Removing packages from $target_file"
				while IFS= read -r package; do
					sed -i "/^$package$/d" "$target_file"
				done <"$PROFILE_PATH_EDITION/$remove_file"
			else
				msg_warning "$target_file does not exist. Skipping removals."
			fi
		else
			msg_warning "$remove_file not found in $PROFILE_PATH_EDITION. Skipping."
		fi
	done

	msg 'Execute comandos especiais, se existirem'
	if [[ -f "$PROFILE_PATH_EDITION/special-commands.sh" ]]; then
		bash "$PROFILE_PATH_EDITION/special-commands.sh"
	fi

	msg 'Configurar o nome da distribuição e ISO'
	if [[ -f /usr/lib/manjaro-tools/util.sh ]]; then
		sudo sed -i "s/dist_name=.*/dist_name=${DISTRONAME,,}/" /usr/lib/manjaro-tools/util.sh
		sudo sed -i "s/iso_name=.*/iso_name=${DISTRONAME,,}/" /usr/lib/manjaro-tools/util.sh

		msg 'Configurar a marca da distribuição'
		sudo sed -i "s/dist_branding=.*/dist_branding=${DISTRONAME,,}/" /usr/lib/manjaro-tools/util.sh
	fi

	if [[ -f /usr/lib/manjaro-tools/util-iso.sh ]]; then
		msg 'Modificar o nome do arquivo ISO'
		sudo sed -i "s/_${profile}${_edition}_${dist_release//./}/-live/" /usr/lib/manjaro-tools/util-iso.sh

		msg 'Configurar profile'
		sudo sed -i "s|profile=.*|profile=\"$EDITION\"|" /usr/lib/manjaro-tools/util-iso.sh
		sudo sed -i "s|profile_dir=.*|profile_dir=\"$PROFILE_PATH/$EDITION\"|" /usr/lib/manjaro-tools/util-iso.sh

		msg 'Desabilitar a verificação de versão do kernel'
		sudo sed -i '/${iso_kernel}/s/^/#/' /usr/lib/manjaro-tools/util-iso.sh
	fi

	msg 'Adicionar limpezas da ISO'
	add_iso_cleanups

	msg 'Adicionar root-overlay'
	sudo sed -i '/copy_overlay "${profile_dir}\/root-overlay" "${path}"/a [[ -e ${profile_dir}\/root-overlay ]] && copy_overlay "${profile_dir}\/root-overlay" "${path}"' /usr/lib/manjaro-tools/util-iso.sh

	msg 'Habilitar plymouth e kms'
	sudo sed -i 's/keyboard keymap/keyboard keymap kms plymouth/g' /usr/share/manjaro-tools/mkinitcpio.conf

	msg 'Alterar pacman e adicionar --needed'
	sudo sed -i 's/pacman -Syu --noconfirm || abort/pacman -Syu --needed --noconfirm || abort/' /usr/lib/manjaro-tools/util-pkg-chroot.sh

	msg "Manjaro tools setup completed."
	if $DEBUG; then
		replicate '#'
		msg "Directory contents of $VAR_CACHE_MANJARO_TOOLS_ISO:"
		ls -la "$VAR_CACHE_MANJARO_TOOLS_ISO"
		replicate '#'
	fi

}
export -f setup_manjaro_tools

configure_dwarfs() {
	msg "Configurando DwarFS como sistema de arquivos da ISO..."
	# Backup dos arquivos originais
	sudo sed -i 's/make_sfs\s\+\"\${sfs_dir}\"/make_dwarfs "${sfs_dir}"/g' /usr/lib/manjaro-tools/util-iso.sh
	# Substituir funções no util-iso-image.sh
	sudo tee -a /usr/lib/manjaro-tools/util-iso.sh >/dev/null <<-'EOF_DWARFS'

		# Função para criar imagem DwarFS
		build_dwarfs_image() {
		  local src="$1"
		  local destname="$2"
		  local dest="$3"
		  local comp_args=()

		  # Configuração dos argumentos
		  comp_args+=(-i "$src")
		  comp_args+=(-o "$dest/$destname")
		  comp_args+=(--compress-level=9)
		  comp_args+=(--block-size-bits=22)
		  #comp_args+=(--max-block-size=1M)
		  comp_args+=(--num-workers=$(nproc))

		  # Logs para depuração
		  msg2 "Creating DwarFS image, this may take some time..."
		  msg2 "Source: $src"
		  msg2 "Destination: $dest/$destname"
		  msg2 "Compression Level: 9"
		  msg2 "Block Size Bits: 22"
		  msg2 "Workers: $(nproc)"
		  msg2 "DwarFS ALL parameters: ${comp_args[*]}"

		  # Execução
		  mkdwarfs "${comp_args[@]}"
		}

		# $1: file
		make_checksum_dwarfs(){
		  msg2 "Creating md5sum ..."
		  cd $1
		  md5sum $2.dwarfs > $2.md5
		  cd ${OLDPWD}
		}

		# $1: image path
		make_dwarfs() {
		  local src="$1"
		  if [[ ! -e "${src}" ]]; then
		    error "The path %s does not exist" "${src}"
		    return 1
		  fi
		  local timer=$(get_timer) dest=${iso_root}/${iso_name}/${target_arch}
		  local name=${1##*/}
		  #local sfs="${dest}/${name}.dwarfs"
		  local sfs="${dest}/${name}.sfs"
		  mkdir -p ${dest}
		  msg "Generating DwarFS image for %s" "${src}"
		    if [[ -f "${sfs}" ]]; then
		        local has_changed_dir=$(find ${src} -newer ${sfs})
		        msg2 "Possible changes for %s ..." "${src}"  >> ${tmp_dir}/buildiso.debug
		        msg2 "%s" "${has_changed_dir}" >> ${tmp_dir}/buildiso.debug
		        if [[ -n "${has_changed_dir}" ]]; then
		            msg2 "DwarFS image %s is not up to date, rebuilding..." "${sfs}"
		            rm "${sfs}"
		        else
		            msg2 "DwarFS image %s is up to date, skipping." "${sfs}"
		            return
		        fi
		    fi

		    if ${persist}; then
		        local size=32G
		        local mnt="${mnt_dir}/${name}"
		        msg2 "Creating ext4 image of %s ..." "${size}"
		        truncate -s ${size} "${src}.img"
		        local ext4_args=()
		        ${verbose} && ext4_args+=(-q)
		        ext4_args+=(-O ^has_journal,^resize_inode -E lazy_itable_init=0 -m 0)
		        mkfs.ext4 ${ext4_args[@]} -F "${src}.img" &>/dev/null
		        tune2fs -c 0 -i 0 "${src}.img" &> /dev/null
		        mount_img "${work_dir}/${name}.img" "${mnt}"
		        msg2 "Copying %s ..." "${src}/"
		        cp -aT "${src}/" "${mnt}/"
		        umount_img "${mnt}"
		    fi

		    msg2 "Creating DwarFS image, this may take some time..."
		    local used_kernel=${kernel:5:1} mksfs_args=()
		    if ${persist}; then
		      mksfs_args+=(${work_dir}/${name}.img)
		    else
		      mksfs_args+=(${src})
		    fi
		    mksfs_args+=(${sfs} -noappend)
		    local highcomp
		    [[ "${iso_compression}" == "xz" ]] && highcomp="-b 1024K -Xbcj x86"
		    [[ "${iso_compression}" == "zstd" ]] && highcomp="-b 1024K -Xcompression-level 6" #compression level max 22 (default 15)
		    mksfs_args+=(-comp ${iso_compression} ${highcomp})
		    msg2 "SquashFS parameters: ${mksfs_args[*]}"

		    if ${verbose}; then
		      #mksquashfs "${mksfs_args[@]}" >/dev/null
		      build_dwarfs_image "$src" "$sfs" >/dev/null
		    else
		      #mksquashfs "${mksfs_args[@]}"
		      build_dwarfs_image "$src" "$sfs"
		    fi
		    #make_checksum_dwarfs "${dest}" "${name}"
		    make_checksum "${dest}" "${name}"
		    ${persist} && rm "${src}.img"

		    if [[ -n ${gpgkey} ]]; then
		      make_sig "${dest}" "${name}"
		    fi
		    show_elapsed_time "${FUNCNAME}" "${timer_start}"
		}
	EOF_DWARFS

	# Configurar mkinitcpio
	#sudo sed -i 's/MODULES=()/MODULES=(dwarfs)/' /etc/mkinitcpio.conf
	#if ! grep -q "dwarfs" /etc/mkinitcpio.conf; then
	#	sudo sed -i 's/HOOKS=(base udev/HOOKS=(base udev dwarfs/' /etc/mkinitcpio.conf
	#fi
	#sudo mkinitcpio -P
	msg "Configuração do DwarFS concluída"
}
export -f configure_dwarfs

configure_mesa() {
	msg 'Iniciando configuração de pacotes Mesa para o kernel.'
	if [[ "$KERNEL" =~ ^(latest|xanmod)$ ]]; then
		{
			echo ''
			echo "mesa-tkg-stable"
			echo "lib32-mesa-tkg-stable"
		} >>"$PROFILE_PATH_EDITION"/Packages-Root

		if [[ -f "$PROFILE_PATH_EDITION/Packages-Desktop" && -f "$PROFILE_PATH_EDITION/Packages-Mhwd" ]]; then
			sed -i '/libva-mesa/d; /vulkan-swrast/d' "$PROFILE_PATH_EDITION"/Packages-{Desktop,Mhwd}
		else
			msg_warning "Erro: Um ou mais arquivos Packages-{Desktop,Mhwd} não encontrados!" >&2
		fi
	fi
}
export -f configure_mesa

configure_kernel() {
	msg "Configurando kernel: $KERNEL"
	case "$KERNEL" in
	oldLts)
		KERNEL=$(curl -s https://www.kernel.org/feeds/kdist.xml |
			grep ": longterm" |
			sed -n 's/.*<title>\(.*\): longterm<\/title>.*/\1/p' |
			rev | cut -d "." -f2,3 | rev |
			sed 's/\.//g' | tail -n1)
		;;

	lts)
		KERNEL=$(curl -s https://www.kernel.org/feeds/kdist.xml |
			grep ": longterm" |
			sed -n 's/.*<title>\(.*\): longterm<\/title>.*/\1/p' |
			rev | cut -d "." -f2,3 | rev |
			sed 's/\.//g' | head -n1)
		;;

	latest)
		KERNEL=$(curl -s https://raw.githubusercontent.com/biglinux/linux-latest/stable/PKGBUILD |
			awk -F= '/kernelver=/{print $2}')
		;;

	xanmod*)
		KERNEL="-$KERNEL"
		;;
	esac

	msg 'Limpar kernels anteriores de todos os Packages-*, mas manter linux-firmware'
	for pkg_file in "$PROFILE_PATH_EDITION"/Packages-*; do
		msg_info "Processando $pkg_file"
		sed -i '/^linux[0-9]/d' "$pkg_file"
		sed -i '/^linux-latest/d' "$pkg_file"
	done

	msg 'Definir KERNEL_NAME e adicionar linux-firmware se necessário'
	if [[ "$KERNEL" == "-xanmod"* ]]; then
		KERNEL_NAME="${KERNEL#-}"
		msg_info "Adicionar linux-firmware ao $PROFILE_PATH_EDITION/Packages-Root"
		echo "linux-firmware" >>"$PROFILE_PATH_EDITION/Packages-Root"
	elif [[ "$KERNEL" == "latest" ]]; then
		KERNEL_NAME="latest"
	else
		KERNEL_NAME="$KERNEL"
	fi

	msg 'Criar KERNEL_VERSION_DOT'
	if [[ "$KERNEL_NAME" =~ ^[0-9]+$ ]]; then
		if [[ ${#KERNEL_NAME} -eq 3 ]]; then
			KERNEL_VERSION_DOT="${KERNEL_NAME:0:1}.${KERNEL_NAME:1:2}"
		elif [[ ${#KERNEL_NAME} -eq 2 ]]; then
			KERNEL_VERSION_DOT="${KERNEL_NAME:0:1}.${KERNEL_NAME:1:1}"
		else
			KERNEL_VERSION_DOT="$KERNEL_NAME"
		fi
	else
		KERNEL_VERSION_DOT="$KERNEL_NAME"
	fi
	msg_info "KERNEL_VERSION_DOT set to: $KERNEL_VERSION_DOT"

	msg 'Modificar a função prepare_boot_extras em util-iso-boot.sh'
	sudo sed -i "/prepare_boot_extras()/,/^}/c\\
  prepare_boot_extras(){\\
      mkdir -p \"\$2\"\\
      cp \$1/boot/amd-ucode.img \$2/amd_ucode.img\\
      cp \$1/boot/intel-ucode.img \$2/intel_ucode.img\\
      cp \$1/usr/share/licenses/amd-ucode/LIC* \$2/amd_ucode.LICENSE\\
      cp \$1/usr/share/licenses/intel-ucode/LIC* \$2/intel_ucode.LICENSE\\
      cp \$1/boot/memtest86+/memtest.bin \$2/memtest\\
      local kernel_file=\$(ls \$1/boot/vmlinuz-${KERNEL_VERSION_DOT}-* 2>/dev/null || ls \$1/boot/vmlinuz-*-${KERNEL_VERSION_DOT}* 2>/dev/null)\\
      if [ -n \"\$kernel_file\" ]; then\\
          cp \"\$kernel_file\" \$2/vmlinuz-x86_64\\
          echo \"Kernel copied: \$kernel_file -> \$2/vmlinuz-x86_64\"\\
      else\\
          echo \"Error: Kernel file not found for KERNEL_VERSION_DOT=${KERNEL_VERSION_DOT}\"\\
          ls -l \$1/boot/\\
      fi\\
  }" /usr/lib/manjaro-tools/util-iso-boot.sh
	msg_info "KERNEL_NAME set to: $KERNEL_NAME"

	msg 'Substituir KERNEL pelos pacotes de kernel específicos em todos os Packages-*'
	for pkg_file in "$PROFILE_PATH_EDITION"/Packages-*; do
		msg_info "Processando $pkg_file"
		sed -i "s/^KERNEL\b/linux${KERNEL_NAME}/g" "$pkg_file"
		sed -i "s/^KERNEL-headers\b/linux${KERNEL_NAME}-headers/g" "$pkg_file"
		sed -i "s/^KERNEL-\(.*\)/linux${KERNEL_NAME}-\1/g" "$pkg_file"
		#if $DEBUG; then
		# msg 'Conteúdo dos arquivos Packages após a limpeza e substituição do kernel:'
		# replicate '#'
		# msg_info "cat $pkg_file"
		# cat "$pkg_file" || true
		# replicate '#'
		#fi
	done
}
export -f configure_kernel

add_repos_to_pacman_conf_into_iso_distro() {
	local config_file="$1"
	local bigcommunity_branch="$2"
	local biglinux_branch="$3"
	local chililinux_branch="$4"
	local config_dir

	config_dir=$(dirname "$config_file")
	# Ensure the directory exists
	mkdir -p "$config_dir"

	# Community repositories
	if [[ "${DISTRONAME,,}" == "bigcommunity" ]]; then
		if [[ "${bigcommunity_branch,,}" == "testing" ]]; then
			add_community-testing | sudo tee -a "$config_file" >/dev/null
			add_community-stable | sudo tee -a "$config_file" >/dev/null
			add_community-extra | sudo tee -a "$config_file" >/dev/null
		else
			add_community-stable | sudo tee -a "$config_file" >/dev/null
			add_community-extra | sudo tee -a "$config_file" >/dev/null
		fi
	fi

	# Chililinux repositories
	if [[ "${DISTRONAME,,}" == "chililinux" ]]; then
		if [[ "${chililinux_branch,,}" == "testing" ]]; then
			add_chili-testing | sudo tee -a "$config_file" >/dev/null
			add_chili-stable | sudo tee -a "$config_file" >/dev/null
			add_chili-extra | sudo tee -a "$config_file" >/dev/null
		else
			add_chili-stable | sudo tee -a "$config_file" >/dev/null
			add_chili-extra | sudo tee -a "$config_file" >/dev/null
		fi
	fi

	if [[ "$biglinux_branch" == "testing" ]]; then
		add_biglinux-testing | sudo tee -a "$config_file" >/dev/null
		add_biglinux-stable | sudo tee -a "$config_file" >/dev/null
	else
		add_biglinux-stable | sudo tee -a "$config_file" >/dev/null
	fi
}
export -f add_repos_to_pacman_conf_into_iso_distro

set_build_info() {
	local release_file
	local release_dir

	case "$DISTRONAME" in
	bigcommunity) release_file="$PROFILE_PATH_EDITION/root-overlay/etc/big-release" ;;
	biglinux) release_file="$PROFILE_PATH_EDITION/root-overlay/etc/big-release" ;;
	chililinux) release_file="$PROFILE_PATH_EDITION/root-overlay/etc/chili-release" ;;
	manjaro) release_file="$PROFILE_PATH_EDITION/root-overlay/etc/manjaro-release" ;;
	esac
	release_dir=$(dirname "$release_file")

	# Ensure the directory exists
	mkdir -p "$release_dir"
	{
		echo "BUILD_RELEASE=$RELEASE_TAG"
		echo "BUILD_BRANCH=$BIGLINUX_BRANCH"
		echo "UNIX_TIMESTAMP=$(($(date +%s) / 86400))"
	} >>"$release_file"
	msg_info "Build info written to $release_file"
}
export -f set_build_info

verificar_iso_profiles_conf() {
	local config_file="$HOME_FOLDER/.config/manjaro-tools/iso-profiles.conf"

	# Verifica se o arquivo existe
	if [[ -f "$config_file" ]]; then
		msg_info "O arquivo $config_file existe."

		# Verifica se o arquivo contém a linha com 'run_dir='
		local run_dir_value
		run_dir_value=$(grep "^run_dir=" "$config_file" | cut -d'=' -f2)

		if [[ -n "$run_dir_value" ]]; then
			if [[ "$run_dir_value" == "/"* ]]; then
				msg_info "A linha 'run_dir=' está presente e o valor é: $run_dir_value"
			else
				msg_warning "A linha 'run_dir=' está presente, mas o valor parece incompleto."
				exit 1
			fi
		else
			msg_warning "A linha 'run_dir=' está presente, mas não contém um valor."
			exit 1
		fi
	else
		msg_warning "O arquivo $config_file não existe."
		exit 1
	fi
}
export -f verificar_iso_profiles_conf

configure_iso_name() {
	replicate "-"
	msg_raw "DISTRONAME          : $DISTRONAME"
	msg_raw "MANJARO_BRANCH      : $MANJARO_BRANCH"
	msg_raw "BIGCOMMUNITY_BRANCH : $BIGCOMMUNITY_BRANCH"
	msg_raw "ISO_LABEL           : ${VOL_ID}"
	replicate "-"

	msg 'Configurando nome da ISO'
	msg_info "Usando ${VOL_ID} para o LABEL/VOL_ID da ISO"
	#sed -i "s/label=.*/label=${DISTRONAME}_$RELEASE_TAG.iso/"   "$PROFILE_PATH_EDITION"/profile.conf
	sed -i "s/label=.*/label=${VOL_ID}/" "$PROFILE_PATH_EDITION"/profile.conf
	sudo sed -i "s/iso_label=.*/iso_label=${VOL_ID}/" "/usr/lib/manjaro-tools/util-iso.sh"

	if [[ "$DISTRONAME" == 'bigcommunity' ]]; then
		case "$MANJARO_BRANCH/$BIGCOMMUNITY_BRANCH" in
		stable/stable) ISO_BASENAME="${DISTRONAME}_STABLE_${EDITION}_${RELEASE_TAG%%_*}_k${KERNEL}.iso" ;;
		stable/testing | testing/*) ISO_BASENAME="${DISTRONAME}_BETA_${EDITION}_${RELEASE_TAG%%_*}_k${KERNEL}.iso" ;;
		unstable/*) ISO_BASENAME="${DISTRONAME}_DEVELOPMENT_${EDITION}_${RELEASE_TAG%%_*}_k${KERNEL}.iso" ;;
		esac
	elif [[ "$DISTRONAME" == 'biglinux' ]]; then
		case "$MANJARO_BRANCH/$BIGLINUX_BRANCH" in
		stable/stable) ISO_BASENAME="${DISTRONAME}_STABLE_${EDITION}_${RELEASE_TAG%%_*}_k${KERNEL}.iso" ;;
		stable/testing | testing/*) ISO_BASENAME="${DISTRONAME}_BETA_${EDITION}_${RELEASE_TAG%%_*}_k${KERNEL}.iso" ;;
		unstable/*) ISO_BASENAME="${DISTRONAME}_DEVELOPMENT_${EDITION}_${RELEASE_TAG%%_*}_k${KERNEL}.iso" ;;
		esac
	elif [[ "$DISTRONAME" == 'manjaro' ]]; then
		case "$MANJARO_BRANCH" in
		stable) ISO_BASENAME="${DISTRONAME}_STABLE_${EDITION}_${RELEASE_TAG%%_*}_k${KERNEL}.iso" ;;
		testing) ISO_BASENAME="${DISTRONAME}_BETA_${EDITION}_${RELEASE_TAG%%_*}_k${KERNEL}.iso" ;;
		unstable) ISO_BASENAME="${DISTRONAME}_DEVELOPMENT_${EDITION}_${RELEASE_TAG%%_*}_k${KERNEL}.iso" ;;
		esac
	elif [[ "$DISTRONAME" == 'chililinux' ]]; then
		case "$MANJARO_BRANCH/$CHILILINUX_BRANCH" in
		stable/stable) ISO_BASENAME="${DISTRONAME}_STABLE_${EDITION}_${RELEASE_TAG%%_*}_k${KERNEL}.iso" ;;
		stable/testing | testing/*) ISO_BASENAME="${DISTRONAME}_BETA_${EDITION}_${RELEASE_TAG%%_*}_k${KERNEL}.iso" ;;
		unstable/*) ISO_BASENAME="${DISTRONAME}_DEVELOPMENT_${EDITION}_${RELEASE_TAG%%_*}_k${KERNEL}.iso" ;;
		esac
	else
		case "$MANJARO_BRANCH/$BIGLINUX_BRANCH" in
		stable/stable) ISO_BASENAME="${DISTRONAME}_STABLE_${EDITION}_${RELEASE_TAG%%_*}_k${KERNEL}.iso" ;;
		stable/testing | testing/*) ISO_BASENAME="${DISTRONAME}_BETA_${EDITION}_${RELEASE_TAG%%_*}_k${KERNEL}.iso" ;;
		unstable/*) ISO_BASENAME="${DISTRONAME}_DEVELOPMENT_${EDITION}_${RELEASE_TAG%%_*}_k${KERNEL}.iso" ;;
		esac
	fi
	msg_info "ISO_BASENAME set to: $ISO_BASENAME"
}
export -f configure_iso_name

build_iso() {
	replicate "########################## RESUMO #################################" 1
	msg_raw "BUILD COMMAND            : buildiso ${SCOPE:+-f} -p $EDITION -b $MANJARO_BRANCH -k ${KERNEL_NAME} ${OFFICE:+-o}"
	msg_raw "PROFILE_PATH             : $PROFILE_PATH"
	msg_raw "PROFILE_PATH_EDITION     : $PROFILE_PATH_EDITION"
	msg_raw "DISTRONAME               : $DISTRONAME"
	msg_raw "EDITION                  : $EDITION"
	msg_raw "MANJARO_BRANCH           : $MANJARO_BRANCH"
	msg_raw "BIGCOMMUNITY_BRANCH      : $BIGCOMMUNITY_BRANCH"
	msg_raw "BIGLINUX_BRANCH          : $BIGLINUX_BRANCH"
	msg_raw "CHILILINUX_BRANCH        : $CHILILINUX_BRANCH"
	msg_raw "KERNEL_VERSION_DOT       : ${KERNEL_VERSION_DOT}"
	msg_raw "KERNEL_NAME              : ${KERNEL_NAME}"
	msg_raw "SCOPE                    : $SCOPE"
	msg_raw "OFFICE                   : $OFFICE"
	replicate "-"
	msg_raw "WORK_PATH                : $WORK_PATH"
	msg_raw "WORK_PATH_ISO_PROFILES   : $WORK_PATH_ISO_PROFILES"
	msg_raw "PATH_MANJARO_ISO_PROFILES: $PATH_MANJARO_ISO_PROFILES"
	msg_raw "ISO_BASENAME             : $ISO_BASENAME"
	replicate "-"
	msg_raw "TMATE debug              : $TMATE"
	msg_raw "BASH debug               : $DEBUG"
	msg_raw "BUILDUSER_RUN_DIR        : $(</"$HOME_FOLDER"/.config/manjaro-tools/iso-profiles.conf)" || true
	replicate "#"

	verificar_iso_profiles_conf
	msg "Executar buildiso e capturar o código de saída"
	msg_info 'LC_ALL=C sudo -u "$USERNAME" bash -c "buildiso -d zstd ${SCOPE:+-f} -p $EDITION -b $MANJARO_BRANCH -k linux${KERNEL_NAME} ${OFFICE:+-o};exit \$?"'

	LC_ALL=C sudo -u "$USERNAME" bash -c "buildiso -q -v"
	if $DEBUG; then
		LC_ALL=C sudo -u "$USERNAME" bash -c "buildiso -d zstd ${SCOPE:+-f} -p $EDITION -b $MANJARO_BRANCH -k linux${KERNEL_NAME} ${OFFICE:+-o};exit \$?"
	else
		#LC_ALL=C sudo -u "$USERNAME" bash -c "buildiso -d zstd ${SCOPE:+-f} -p $EDITION -b $MANJARO_BRANCH -k linux${KERNEL_NAME} ${OFFICE:+-o} > /dev/null 2>&1; exit \$?"
		LC_ALL=C sudo -u "$USERNAME" bash -c "buildiso -d zstd ${SCOPE:+-f} -p $EDITION -b $MANJARO_BRANCH -k linux${KERNEL_NAME} ${OFFICE:+-o} 1>/dev/null; exit \$?"
	fi
	BUILD_EXIT_CODE=$?

	msg 'Testando se buildiso falhou, e caso sair com o código de erro'
	if [[ $BUILD_EXIT_CODE -ne 0 ]]; then
		msg_warning "ERROR: buildiso command failed with exit code $BUILD_EXIT_CODE"
		exit $BUILD_EXIT_CODE
	fi
	msg_info "buildiso command exit code $BUILD_EXIT_CODE"

	#	msg 'Verificar arquivos de kernel e tentar cópia manual, independentemente do resultado do buildiso'
	#	msg_info 'Checking kernel files in rootfs:'
	#	find /var/lib/manjaro-tools/buildiso/"${EDITION}"/x86_64/rootfs/boot -name "vmlinuz*"
	#
	#	msg 'Checking kernel files in iso/boot:'
	#	if ! find /var/lib/manjaro-tools/buildiso/"${EDITION}"/iso/boot -name "vmlinuz*"; then
	#		# Warning: Kernel file not found in iso/boot. Attempting manual copy
	#		sudo mkdir -p "/var/lib/manjaro-tools/buildiso/${EDITION}/iso/boot"
	#		sudo cp -v /var/lib/manjaro-tools/buildiso/"${EDITION}"/x86_64/rootfs/boot/vmlinuz* "/var/lib/manjaro-tools/buildiso/${EDITION}/iso/boot/" || echo "Manual copy failed"
	#	fi

	if $DEBUG; then
		msg 'Exibir conteúdo de diretórios relevantes para diagnóstico'
		replicate '#'
		msg_info "Contents of /var/lib/manjaro-tools/buildiso/${EDITION}/x86_64/rootfs/boot:"
		ls -la /var/lib/manjaro-tools/buildiso/"${EDITION}"/x86_64/rootfs/boot
		replicate '#'
		msg_info "Contents of /var/lib/manjaro-tools/buildiso/${EDITION}/iso/boot:"
		ls -la /var/lib/manjaro-tools/buildiso/"${EDITION}"/iso/boot
		replicate '#'
	fi
}
export -f build_iso

cleanup_and_move_files() {
	OUTPUT_ISO_PATH_NAME=$(find "$VAR_CACHE_MANJARO_TOOLS_ISO" -type f -iname "*.iso" -exec stat -c '%Y %n' {} + | sort -nr | awk 'NR==1 {print $2}')
	FILE_PKG=$(find "$VAR_CACHE_MANJARO_TOOLS_ISO" -type f -iname "*-pkgs.txt" -exec stat -c '%Y %n' {} + | sort -nr | awk 'NR==1 {print $2}')
	{
		echo "ISO_BASENAME=$ISO_BASENAME"
		echo "OUTPUT_ISO_PATH_NAME=$OUTPUT_ISO_PATH_NAME"
		echo "FILE_PKG=$FILE_PKG"
	} >>"$GITHUB_ENV"
	echo "iso_path=$WORK_PATH/$ISO_BASENAME" >>"$GITHUB_OUTPUT"

	msg "Movendo ISO e PKGS para $WORK_PATH"
	sudo mv -f "$OUTPUT_ISO_PATH_NAME" "$WORK_PATH/$ISO_BASENAME" || msg_warning "ERRO: Falha ao mover ISO $OUTPUT_ISO_PATH_NAME"
	sudo mv -f "$FILE_PKG" "$WORK_PATH/${ISO_BASENAME}.pkgs" || msg_warning "ERRO: Falha ao mover PKGS $FILE_PKG"

	replicate '#'
	msg_raw "OUTPUT_ISO_PATH_NAME: $OUTPUT_ISO_PATH_NAME"
	msg_raw "FILE_PKG            : $FILE_PKG"
	msg_raw "ISO_BASENAME        : $ISO_BASENAME"
	msg_raw "NEW PATH ISO FILE   : $WORK_PATH/$ISO_BASENAME"
	msg_raw "NEW PATH ISO PKGS   : $WORK_PATH/${ISO_BASENAME}.pkgs"
	replicate '#'
}
export -f cleanup_and_move_files

sh_install_manjaro_build_packages() {
	cleaning_working_directories
	msg 'Install tools packages required'
	sudo pacman -Sy --quiet --needed --noconfirm \
		git \
		base-devel \
		cdrkit &>/dev/null

	msg 'Install the manjaro-tools-packages required'
	if sudo pacman -Sy --quiet --noconfirm \
		manjaro-chrootbuild \
		manjaro-tools-iso-git \
		manjaro-tools-base-git \
		manjaro-tools-pkg-git \
		manjaro-tools-yaml-git &>/dev/null; then
		msg "All packages installed successfully."
	else
		die "${red}" "[L1656]Failed to install manjaro-tools-packages. ${reset}"
	fi
}

make_iso() {
	local start_datetime
	local end_datetime
	declare -g VOL_ID="${DISTRONAME^^}_LIVE_${EDITION^^}"

	start_time=$(date +%s) # Obtém o tempo de início em segundos desde a época Unix
	start_datetime=$(date)

	msg_info "Construindo ISO como usuário '$USERNAME'"
	sh_install_manjaro_build_packages
	checkout_iso-profiles_and_clean_directories
	check_directories_and_path
	configurar_manjaro_tools_para_usuario_builduser
	configure_repositories_and_build_environment
	# Community Pre Config Build ISO
	setup_manjaro_tools
	#configure_dwarfs # substituto ao squashfs
	#configure_mesa
	# Starting kernel configuration
	configure_kernel

	# Starting repository configuration
	msg_info "Adicionando repositórios em: $WORK_PATH_ISO_PROFILES/shared/pacman.conf"
	add_repos_to_pacman_conf_into_iso_distro \
		"$WORK_PATH_ISO_PROFILES/shared/pacman.conf" \
		"$BIGCOMMUNITY_BRANCH" \
		"$BIGLINUX_BRANCH" \
		"$CHILILINUX_BRANCH"

	set_build_info
	configure_iso_name
	build_iso
	cleanup_and_move_files
	if $DEBUG; then
		ls -lah "$PWD"
	fi
	end_datetime=$(date)
	msg_info "$APP - Construção ISO ${ISO_BASENAME} finalizada com sucesso"
	msg_info "Start Date time  : $start_datetime"
	msg_info "Finish Date Time : $end_datetime"
	msg_info "Time elapsed     : ${red}$(sh_time_elapsed)"
	exit 0
}

#check_user() {
#	# Verifica se o usuário é root
#	if [[ "$EUID" -eq 0 ]]; then
#  	set_varcolors
#		die "${red}" "Construção da ISO não pode ser com usuário root ${reset}"
#	fi
#}

## start script
if test $# -lt 1; then
	set_varcolors
	sh_usage
	exit $(($# ? 0 : 1))
fi

# Loop através de todos os parâmetros ($@)
set_varcolors
for arg in "$@"; do
	if [[ "$arg" = @(-n|--nocolor) ]]; then
		nocolor=true
		[[ "$nocolor" == "true" ]] && unset_varcolors
	elif [[ "$arg" = @(-V|--version) ]]; then
		set_varcolors
		sh_version
		exit $(($# ? 0 : 1))
	elif [[ "$arg" = @(-h|--help) ]]; then
		set_varcolors
		sh_usage
		exit $(($# ? 0 : 1))
	elif [[ "$arg" = @(-a|--auto|--automatic) ]]; then
		if [[ -t 0 ]]; then
			die "Rodando interativamente (terminal presente).\n    Esta opção deve ser somente utilizada via Github Actions"
		fi
		IS_AUTO=true
	elif [[ "$arg" = @(-m|--manual|--standalone) ]]; then
		ccabec="$APP --manual - Construir ISO localmente escolhendo manualmente os parâmetros"
		IS_AUTO=false
		PARAM_DEFAULT=false
	elif [[ "$arg" = @(-i|--iso-profiles) ]]; then
		ccabec="$APP --iso-profiles - Adicionar repositorio iso-profiles customizado do Github"
		IS_AUTO=false
		VALUE_DEFAULT=true
		IS_ADD_PERFIL=true
		IS_ADD_PROFILE=true
		sh_add_iso_profiles
	elif [[ "$arg" = @(-c|--create_perfil) ]]; then
		ccabec="$APP --create_perfil - Adicionar perfil customizado de ISO"
		IS_AUTO=false
		VALUE_DEFAULT=false
		IS_ADD_PERFIL=true
		configure_vars
	elif [[ "$arg" = @(-g|--get_perfil) ]]; then
		ccabec="$APP --get_perfil - Selecionar perfil customizado de ISO"
		IS_AUTO=false
		VALUE_DEFAULT=true
		IS_BUILD_ISO_RESUME=false
	elif [[ "$arg" = @(-l|--list_perfil) ]]; then
    sh_list_perfil
		exit 0
	elif [[ "$arg" = @(-d|--defa|--default) ]]; then
		ccabec="$APP --default"
		sh_get_all_custom_perfil
		Names="${!ACustomPerfilKey[*]}"
		if [[ -n "$2" && "${Names}" =~ "$2" ]]; then
			var="$2"
			perfil_name="${var%"${var##*[![:space:]]}"}"
			IS_AUTO=false
			PARAM_DEFAULT=true
			sh_read_custom_perfil "${ACustomPerfilKey[$perfil_name]}"
			shift
		else
			if ! get_perfil; then
				exit 0
			fi
			PARAM_DEFAULT=true
			shift
		fi
		break
	elif [[ "$arg" = @(-r|--remove_perfil) ]]; then
		ccabec="$APP --remove_perfil"
		IS_AUTO=false
		PARAM_DEFAULT=true
		sh_remove_custom_perfil
		exit 0
	else
		set_varcolors
		sh_usage
		exit $(($# ? 0 : 1))
	fi
done

set_varcolors
if ! $IS_AUTO; then
	configure_vars
fi
make_iso
